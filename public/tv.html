<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Barfly Social â€” TV</title>
  <style>
    :root{
      --bg:#070a12; --txt:#e9f0ff; --muted:#a7b3d1; --line:rgba(255,255,255,.12);
      --good:#2dd4bf; --brand:#60a5fa; --warn:#fbbf24; --bad:#fb7185;
      --shadow:0 10px 30px rgba(0,0,0,.35); --r:18px;
      --net:#60a5fa; --date:#2dd4bf;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:
      radial-gradient(1400px 900px at 10% 0%, rgba(96,165,250,.18), transparent 60%),
      radial-gradient(1200px 800px at 100% 0%, rgba(45,212,191,.14), transparent 55%),
      var(--bg); color:var(--txt);}
    .wrap{max-width:1400px;margin:0 auto;padding:18px}
    .top{display:flex;justify-content:space-between;align-items:flex-start;gap:14px;flex-wrap:wrap;margin-bottom:14px}
    .title{font-weight:1000;font-size:34px;letter-spacing:.5px}
    .sub{color:var(--muted);font-weight:800;line-height:1.35}
    .pillRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
    .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);padding:10px 12px;border-radius:999px;background:rgba(255,255,255,.03);font-size:14px;color:var(--muted);white-space:nowrap}
    .pill b{color:var(--txt)}
    .pill.good{border-color:rgba(45,212,191,.35);background:rgba(45,212,191,.08)}
    .pill.warn{border-color:rgba(251,191,36,.35);background:rgba(251,191,36,.08)}
    .pill.bad{border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.08)}
    .pill.net{border-color:rgba(96,165,250,.38);background:rgba(96,165,250,.10);color:#bcd8ff}
    .pill.date{border-color:rgba(45,212,191,.40);background:rgba(45,212,191,.10);color:#c9fff2}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:14px}
    @media(max-width:1200px){.grid{grid-template-columns:repeat(2,1fr)}}
    @media(max-width:720px){.grid{grid-template-columns:1fr}}
    .card{border:1px solid var(--line);border-radius:var(--r);background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));box-shadow:var(--shadow);padding:16px;min-height:130px}
    .pair{font-weight:1000;font-size:22px;line-height:1.15}
    .meta{margin-top:8px;color:var(--muted);font-weight:900;line-height:1.35}
    .code{display:inline-block;margin-top:10px;padding:8px 10px;border-radius:999px;border:1px solid rgba(45,212,191,.35);background:rgba(45,212,191,.10);color:var(--good);font-weight:1000}
    .code.net{border-color:rgba(96,165,250,.38);background:rgba(96,165,250,.10);color:#bcd8ff}
    .footer{margin-top:14px;border:1px solid var(--line);border-radius:18px;background:rgba(255,255,255,.03);padding:14px;color:var(--muted);font-weight:900;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .big{font-size:18px;color:var(--txt)}
    .hidden{display:none !important;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .k{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);padding:7px 10px;border-radius:999px;background:rgba(255,255,255,.03);color:var(--muted);font-weight:900;font-size:12px}
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div style="min-width:280px">
      <div class="title" id="titleText">Now Matching ðŸ’š</div>
      <div class="sub" id="subText">
        Aliases only â€¢ Sorted high â†’ low â€¢ Visible 3 hours â€¢ Rotates every 10s<br/>
        <span class="k">Only <b>Checked-In</b> guests appear here</span>
      </div>
    </div>

    <div class="pillRow" style="min-width:320px">
      <div class="pill" id="eventPillWrap"><b>Event</b> <span id="eventPill">â€”</span></div>

      <div class="pill"><b>Room</b> <span id="roomPill">â€”</span></div>
      <div class="pill"><b>Session</b> <span id="sessionPill">â€”</span></div>

      <!-- Venue pill hides automatically when All Venues -->
      <div class="pill" id="venuePillWrap"><b>Venue</b> <span id="venuePill">â€”</span></div>

      <div class="pill" id="wsPillWrap"><b>WS</b> <span id="wsPill">DISCONNECTED</span></div>
      <div class="pill" id="syncPillWrap"><b>Host Sync</b> <span id="syncPill">â€”</span></div>

      <!-- Option C hybrid pills -->
      <div class="pill warn"><b>Expected</b> <span id="expectedPill">0</span></div>
      <div class="pill good"><b>Checked In</b> <span id="checkedInPill">0</span></div>
      <div class="pill good"><b>Active</b> <span id="activeMatchesPill">0</span></div>
      <div class="pill" id="hotspotWrap"><b>Tonightâ€™s Hotspot</b> <span id="hotspotPill">â€”</span></div>
    </div>
  </div>

  <div class="grid" id="grid"></div>

  <div class="footer">
    <div class="big" id="footerLead">See your alias pairing? Go to the host stand to connect.</div>
    <div id="footerTag">Barfly Social â€¢ Private Live Matchmaking</div>
  </div>
</div>

<script>
/* ============================================================
   Barfly Social â€” TV (Event-Type Aware)

   âœ… Rules:
   - TV only shows matches where BOTH guests are checked-in.
   - Counts use Option C Hybrid:
       Expected = pending guests who selected a venue
       Checked In = host verified
       Active = TV pairs involving checked-in guests
       Tonightâ€™s Hotspot = venue with most active matches
   - Prefers host-provided counts/hotspot; falls back if missing.
   - Event Type (Dating vs Networking) comes from:
       1) URL: ?event=dating | networking
       2) Host config: eventType / event / type / mode fields (best-effort)
   - Backward compatible if host hasn't added eventType yet.
============================================================ */

const WS_URL = "wss://bar-match-relay.onrender.com";

const ROTATE_MS     = 10 * 1000;
const RESYNC_MS     = 25 * 1000;
const RECONNECT_MS  = 2500;

const HEARTBEAT_MS  = 15 * 1000;
const STALE_MS      = 45 * 1000;   // if no traffic, force reconnect
const SYNC_STALE_MS = 40 * 1000;   // if no tv_sync, show clearer waiting message

const $ = (id)=>document.getElementById(id);

function qs(){
  const u=new URL(location.href);
  const q = Object.fromEntries(u.searchParams.entries());
  q.room    = (q.room || q.roomId || q.barId || "").trim();
  q.session = (q.session || "").trim();
  q.venue   = (q.venue || "").trim();
  q.event   = (q.event || q.eventType || q.type || "").trim().toLowerCase(); // dating | networking
  return q;
}
function esc(s){
  return String(s??"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}

/* Venue normalization:
   - missing / "ALL" / "*" => treated as no filter (All Venues / City mode)
*/
function normVenue(v){
  const s = String(v||"").trim();
  if(!s) return "";
  if(/^all$/i.test(s) || /^allvenues$/i.test(s) || s === "*") return "";
  return s;
}

/* =========================
   EVENT TYPE
========================= */
let EVENT_TYPE = ""; // "dating" | "networking" | ""

function normalizeEventType(raw){
  const s = String(raw||"").trim().toLowerCase();
  if(!s) return "";
  if(s.includes("network")) return "networking";
  if(s.includes("dating")) return "dating";
  // allow short forms
  if(s === "net") return "networking";
  if(s === "date") return "dating";
  return "";
}

function inferEventTypeFromConfig(cfg){
  // best-effort mapping across possible host field names
  const candidates = [
    cfg?.eventType,
    cfg?.event,
    cfg?.type,
    cfg?.mode,                 // if host uses "mode" for event type
    cfg?.event?.type,
    cfg?.settings?.eventType,
    cfg?.settings?.type
  ];
  for(const c of candidates){
    const n = normalizeEventType(c);
    if(n) return n;
  }
  return "";
}

function applyEventUI(){
  const pillWrap = $("eventPillWrap");
  const pill = $("eventPill");

  const title = $("titleText");
  const sub = $("subText");
  const footerLead = $("footerLead");
  const footerTag = $("footerTag");

  const t = EVENT_TYPE || "";

  // default (unknown)
  let eventLabel = "Live Event";
  let pillClass = "pill";
  let titleText = "Now Matching ðŸ’š";
  let subHtml = `Aliases only â€¢ Sorted high â†’ low â€¢ Visible 3 hours â€¢ Rotates every 10s<br/>
    <span class="k">Only <b>Checked-In</b> guests appear here</span>`;
  let footerLeadText = "See your alias pairing? Go to the host stand to connect.";
  let footerTagText = "Barfly Social â€¢ Private Live Matchmaking";

  if(t === "networking"){
    eventLabel = "ðŸ’¼ Professional Networking";
    pillClass = "pill net";
    titleText = "Now Networking ðŸ’¼";
    subHtml = `Aliases only â€¢ Sorted high â†’ low â€¢ Visible 3 hours â€¢ Rotates every 10s<br/>
      <span class="k">Only <b>Checked-In</b> guests appear here</span>`;
    footerLeadText = "See your networking pairing? Go to the host stand to connect.";
    footerTagText = "Barfly Social â€¢ Professional Networking";
  }else if(t === "dating"){
    eventLabel = "ðŸ’š Dating Night";
    pillClass = "pill date";
    titleText = "Now Matching ðŸ’š";
    subHtml = `Aliases only â€¢ Sorted high â†’ low â€¢ Visible 3 hours â€¢ Rotates every 10s<br/>
      <span class="k">Only <b>Checked-In</b> guests appear here</span>`;
    footerLeadText = "See your alias pairing? Go to the host stand to connect.";
    footerTagText = "Barfly Social â€¢ Private Live Matchmaking";
  }

  pillWrap.className = pillClass;
  pill.textContent = eventLabel;

  title.textContent = titleText;
  sub.innerHTML = subHtml;

  footerLead.textContent = footerLeadText;
  footerTag.textContent = footerTagText;
}

/* =========================
   CONFIG (venue names)
========================= */
let HOST_CONFIG = null;

function barNameFromCfg(id){
  const clean = String(id||"").trim();
  if(!clean) return "";
  const b = (HOST_CONFIG?.bars || []).find(x => x.id === clean);
  return (b?.name || clean);
}
function labelVenue(id){
  const clean = String(id||"").trim();
  if(!clean) return "Venue";
  return barNameFromCfg(clean) || clean;
}
function applyVenuePillUI(){
  const q = qs();
  const v = normVenue(q.venue);
  const wrap = $("venuePillWrap");
  const pill = $("venuePill");

  if(!v){
    wrap.classList.add("hidden");
  }else{
    wrap.classList.remove("hidden");
    pill.textContent = labelVenue(v);
  }
}

/* =========================
   WS STATE
========================= */
let WS=null;
let WS_STATE="DISCONNECTED";
let matches=[];                 // incoming from tv_sync (host)
let page=0;

let reconnectTimer=null;
let hbTimer=null;
let staleTimer=null;

let lastTrafficAt = Date.now();
let lastTvSyncAt  = 0;
let lastCountsAt  = 0;

function setWsStatus(s){
  WS_STATE=s;
  $("wsPill").textContent=s;
  $("wsPillWrap").className = "pill " + (s==="CONNECTED"?"good": s==="CONNECTING"?"warn": s==="ERROR"?"bad":"");
}
function setSyncPill(){
  const age = lastTvSyncAt ? Math.max(0, Math.round((Date.now()-lastTvSyncAt)/1000)) : null;
  $("syncPill").textContent = age==null ? "â€”" : `${age}s`;
  const cls = (age==null) ? "" : (age <= 10 ? " good" : age <= 25 ? " warn" : " bad");
  $("syncPillWrap").className = "pill" + cls;
}
function touchTraffic(){ lastTrafficAt = Date.now(); }

function safeSend(obj){
  try{
    if(WS && WS.readyState===WebSocket.OPEN){
      WS.send(JSON.stringify(obj));
      return true;
    }
  }catch{}
  return false;
}

/* TV requests */
function requestSync(){
  const q=qs();
  if(!q.room || !q.session) return;
  safeSend({ type:"request_tv_sync", roomId: q.room, room: q.room, barId: q.room, session: q.session });
}
function requestConfig(){
  const q=qs();
  if(!q.room || !q.session) return;
  safeSend({ type:"request_config", roomId: q.room, room: q.room, barId: q.room, session: q.session });
}

/* heartbeat */
function heartbeatTick(){
  if(WS_STATE!=="CONNECTED") return;
  const q=qs();
  safeSend({ type:"ping", roomId: q.room, room: q.room, barId: q.room, session: q.session, t: Date.now() });
  if(Date.now() - lastTrafficAt > STALE_MS){
    try{ WS?.close(); }catch{}
  }
}
function startHeartbeat(){
  stopHeartbeat();
  touchTraffic();
  hbTimer = setInterval(heartbeatTick, HEARTBEAT_MS);
  staleTimer = setInterval(()=>{
    if(WS_STATE==="CONNECTED" && (Date.now()-lastTrafficAt)>STALE_MS){
      try{ WS?.close(); }catch{}
    }
  }, 5000);
}
function stopHeartbeat(){
  clearInterval(hbTimer); hbTimer=null;
  clearInterval(staleTimer); staleTimer=null;
}

/* =========================
   CHECK-IN FILTER + COUNTS
========================= */

/* A match is TV-eligible ONLY if both checked in.
   Host v11 may send:
     - aCheckedIn / bCheckedIn booleans
     - aStatus / bStatus strings
   Back-compat: if host doesn't send flags, we assume true (older host behavior).
*/
function isCheckedInFlag(m, side){
  const isA = side==="a";
  const v1 = isA ? m.aCheckedIn : m.bCheckedIn;
  const v2 = isA ? m.checkedInA : m.checkedInB;
  const st = isA ? (m.aStatus || m.statusA) : (m.bStatus || m.statusB);

  if(typeof v1 === "boolean") return v1;
  if(typeof v2 === "boolean") return v2;
  if(typeof st === "string") return st.toLowerCase().includes("check");
  return true; // old host fallback
}

function filteredMatches(){
  const q=qs();
  const venue = normVenue(q.venue);
  const t = Date.now();

  let list = (matches || []).filter(m => !m.expiresAt || m.expiresAt > t);

  // enforce check-in
  list = list.filter(m => isCheckedInFlag(m,"a") && isCheckedInFlag(m,"b"));

  // optional venue filter (single-location TV)
  if(venue){
    list = list.filter(m => (m.aVenueId === venue) || (m.bVenueId === venue));
  }

  list.sort((a,b)=>(b.score||0)-(a.score||0));
  return list;
}

function computeHotspotFromList(list){
  const counts = new Map();
  for(const m of list){
    const av = String(m.aVenueId||"").trim();
    const bv = String(m.bVenueId||"").trim();
    if(av) counts.set(av, (counts.get(av)||0)+1);
    if(bv) counts.set(bv, (counts.get(bv)||0)+1);
  }
  let bestId="", bestCount=0;
  for(const [id,c] of counts.entries()){
    if(c > bestCount){ bestId=id; bestCount=c; }
  }
  if(!bestId) return { id:"", label:"â€”" };
  return { id:bestId, label:`${labelVenue(bestId)} (${bestCount})` };
}

function setCountsFromMsg(msg){
  const c = msg.counts || msg.stats || msg.summary || {};

  const expected =
    (typeof c.expected === "number" ? c.expected :
    typeof c.pendingExpected === "number" ? c.pendingExpected :
    typeof msg.expected === "number" ? msg.expected : null);

  const checkedIn =
    (typeof c.checkedIn === "number" ? c.checkedIn :
    typeof c.arrived === "number" ? c.arrived :
    typeof msg.checkedIn === "number" ? msg.checkedIn : null);

  const activeMatches =
    (typeof c.activeMatches === "number" ? c.activeMatches :
    typeof c.tvActive === "number" ? c.tvActive :
    typeof msg.activeMatches === "number" ? msg.activeMatches : null);

  const hotspotLabel =
    (typeof c.hotspotLabel === "string" ? c.hotspotLabel :
     typeof c.hotspot === "string" ? c.hotspot :
     (c.hotspot && typeof c.hotspot === "object" && c.hotspot.label ? String(c.hotspot.label) : null));

  let changed = false;

  if(expected!=null){ $("expectedPill").textContent = String(expected); changed=true; }
  if(checkedIn!=null){ $("checkedInPill").textContent = String(checkedIn); changed=true; }
  if(activeMatches!=null){ $("activeMatchesPill").textContent = String(activeMatches); changed=true; }

  if(hotspotLabel!=null){
    $("hotspotPill").textContent = hotspotLabel || "â€”";
    changed=true;
  }

  if(changed) lastCountsAt = Date.now();
  return changed;
}

function setCountsFallback(){
  const active = filteredMatches();
  $("activeMatchesPill").textContent = String(active.length);
  const hs = computeHotspotFromList(active);
  $("hotspotPill").textContent = hs.label;
}

/* =========================
   RENDER
========================= */
function formatAliasWithVenue(alias, venueId, showVenue){
  const a = alias || "Guest";
  if(!showVenue) return a;
  const v = String(venueId||"").trim();
  if(!v) return a;
  return `${a} @ ${labelVenue(v)}`;
}

function waitingCard(){
  const q = qs();
  const hasHostSync = !!lastTvSyncAt;
  const staleSync = hasHostSync ? (Date.now()-lastTvSyncAt) > SYNC_STALE_MS : true;

  const help = staleSync
    ? `Host hasnâ€™t broadcasted TV data yet (or itâ€™s stale).`
    : `No checked-in pairs right now.`;

  const venue = normVenue(q.venue);
  const venueLine = venue ? `<div style="margin-top:6px">TV Venue Filter: <span class="mono">${esc(labelVenue(venue))}</span></div>` : ``;

  const t = EVENT_TYPE || "";
  const extra = (t==="networking")
    ? `Guests must be <b>Checked In</b> by the host to appear on the networking TV.`
    : `Guests must be <b>Checked In</b> by the host to appear on TV.`;

  return `
    <div class="card">
      <div class="pair">Waiting for checked-in pairsâ€¦</div>
      <div class="meta">
        ${esc(help)}<br/>
        <span class="k">${extra}</span>
        ${venueLine}
      </div>
      <div class="meta" style="margin-top:10px">
        <span class="mono">Tip:</span> Host should click <b>Broadcast Config</b> and then <b>Compute â†’ TV</b> (or similar) if needed.
      </div>
    </div>
  `;
}

function render(){
  setSyncPill();

  const grid=$("grid");
  grid.innerHTML="";
  const list = filteredMatches();

  if(Date.now() - lastCountsAt > 5000){
    setCountsFallback();
  }

  if(!list.length){
    grid.innerHTML = waitingCard();
    return;
  }

  const q=qs();
  const isAllVenues = !normVenue(q.venue);

  const perPage = 9;
  const pages = Math.max(1, Math.ceil(list.length / perPage));
  page = page % pages;

  const labelCode = (EVENT_TYPE === "networking") ? "Connect Code" : "Match Code";
  const codeClass = (EVENT_TYPE === "networking") ? "code net" : "code";

  const defaultPlan = (EVENT_TYPE === "networking")
    ? "See host to connect professionally."
    : "See host to connect.";

  const slice = list.slice(page*perPage, page*perPage + perPage);
  for(const m of slice){
    const el=document.createElement("div");
    el.className="card";

    const left = formatAliasWithVenue(m.aAlias, m.aVenueId, isAllVenues);
    const right = formatAliasWithVenue(m.bAlias, m.bVenueId, isAllVenues);

    const bothVenues = isAllVenues && String(m.aVenueId||"").trim() && String(m.bVenueId||"").trim();
    const venuesLine = bothVenues
      ? `Venues: <span class="mono">${esc(labelVenue(m.aVenueId))}</span> + <span class="mono">${esc(labelVenue(m.bVenueId))}</span>`
      : "";

    el.innerHTML=`
      <div class="pair">${esc(left)} + ${esc(right)} â€” ${Math.round((m.score||0)*100)}%</div>
      <div class="meta">
        ${esc(m.plan || defaultPlan)}
        ${venuesLine ? `<div style="margin-top:6px">${venuesLine}</div>` : ``}
      </div>
      <div class="${codeClass}">${labelCode}: <span class="mono">${esc(m.code||"â€”")}</span></div>
    `;
    grid.appendChild(el);
  }
}

/* =========================
   CONNECT
========================= */
function scheduleReconnect(){
  clearTimeout(reconnectTimer);
  reconnectTimer = setTimeout(()=>connectWS(), RECONNECT_MS);
}

function connectWS(){
  const q=qs();
  $("roomPill").textContent=q.room || "â€”";
  $("sessionPill").textContent=q.session || "â€”";

  // initial event type from URL, if provided
  const urlEvent = normalizeEventType(q.event);
  if(urlEvent){ EVENT_TYPE = urlEvent; applyEventUI(); }

  applyVenuePillUI();

  if(!q.room || !q.session){
    setWsStatus("ERROR");
    $("grid").innerHTML = `
      <div class="card">
        <div class="pair">Missing room/session</div>
        <div class="meta">TV link must include <span class="mono">?room=...&session=...</span></div>
      </div>
    `;
    return;
  }

  stopHeartbeat();
  try{ WS?.close(); }catch{}

  WS = new WebSocket(WS_URL);
  setWsStatus("CONNECTING");

  WS.onopen=()=>{
    setWsStatus("CONNECTED");
    touchTraffic();
    startHeartbeat();

    safeSend({ type:"join", role:"tv", roomId: q.room, room: q.room, barId: q.room, session: q.session });

    requestConfig();
    requestSync();
  };

  WS.onmessage=(ev)=>{
    touchTraffic();
    let msg; try{ msg=JSON.parse(ev.data); }catch{ return; }

    if(msg.type === "ping"){
      const q=qs();
      safeSend({ type:"pong", roomId: q.room, room: q.room, barId: q.room, session: q.session, t: Date.now() });
      return;
    }
    if(msg.type==="pong" || msg.type==="heartbeat" || msg.type==="pong_ack"){ return; }

    // config
    if(msg.type==="config" || msg.type==="event_config"){
      const q=qs();
      const msgRoom = (msg.roomId || msg.room || msg.barId || "").trim();
      if(msg.session && msg.session !== q.session) return;
      if(msgRoom && msgRoom !== q.room) return;

      HOST_CONFIG = msg;

      // event type from host config (only override if host provides a recognized type)
      const fromHost = inferEventTypeFromConfig(msg);
      if(fromHost){
        EVENT_TYPE = fromHost;
        applyEventUI();
      }else{
        // if not set anywhere, keep whatever we already have (URL or default)
        if(!EVENT_TYPE){
          EVENT_TYPE = "";
          applyEventUI();
        }
      }

      applyVenuePillUI();
      render();
      return;
    }

    // tv sync
    if(msg.type==="tv_sync"){
      const q=qs();
      const msgRoom = (msg.roomId || msg.room || msg.barId || "").trim();
      if(msg.session && msg.session !== q.session) return;
      if(msgRoom && msgRoom !== q.room) return;

      lastTvSyncAt = Date.now();

      // event type can also arrive on tv_sync (best-effort)
      const fromSync = normalizeEventType(msg.eventType || msg.event || msg.type);
      if(fromSync && fromSync !== EVENT_TYPE){
        EVENT_TYPE = fromSync;
        applyEventUI();
      }

      matches = (msg.matches || []).map(m=>({
        score: m.score || 0,
        code: m.code || "",
        plan: m.plan || "",
        expiresAt: m.expiresAt || 0,

        aAlias: m.aAlias || m.a || m.aliasA || "",
        bAlias: m.bAlias || m.b || m.aliasB || "",

        aVenueId: m.aVenueId || "",
        bVenueId: m.bVenueId || "",

        aCheckedIn: (typeof m.aCheckedIn === "boolean") ? m.aCheckedIn : (typeof m.checkedInA === "boolean" ? m.checkedInA : undefined),
        bCheckedIn: (typeof m.bCheckedIn === "boolean") ? m.bCheckedIn : (typeof m.checkedInB === "boolean" ? m.checkedInB : undefined),
        aStatus: m.aStatus || m.statusA || "",
        bStatus: m.bStatus || m.statusB || ""
      }));

      setCountsFromMsg(msg);

      page = 0;
      render();
      return;
    }
  };

  WS.onerror=()=>{
    setWsStatus("ERROR");
    try{ WS?.close(); }catch{}
  };

  WS.onclose=()=>{
    setWsStatus("DISCONNECTED");
    stopHeartbeat();
    scheduleReconnect();
  };
}

/* rotate + periodic resync */
setInterval(()=>{ page++; render(); }, ROTATE_MS);
setInterval(()=>{ if(WS_STATE==="CONNECTED") requestSync(); }, RESYNC_MS);
setInterval(()=>{ setSyncPill(); }, 1000);

/* boot */
(function boot(){
  // Apply default event UI immediately (or URL-driven)
  const q=qs();
  EVENT_TYPE = normalizeEventType(q.event) || "";
  applyEventUI();

  connectWS();
  render();
})();
</script>
</body>
</html>












