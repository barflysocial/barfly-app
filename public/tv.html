<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Barfly Social â€” TV</title>
  <style>
    :root{
      --bg:#070a12; --txt:#e9f0ff; --muted:#a7b3d1; --line:rgba(255,255,255,.12);
      --good:#2dd4bf; --brand:#60a5fa; --warn:#fbbf24; --bad:#fb7185;
      --shadow:0 10px 30px rgba(0,0,0,.35); --r:18px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:
      radial-gradient(1400px 900px at 10% 0%, rgba(96,165,250,.18), transparent 60%),
      radial-gradient(1200px 800px at 100% 0%, rgba(45,212,191,.14), transparent 55%),
      var(--bg); color:var(--txt);}
    .wrap{max-width:1400px;margin:0 auto;padding:18px}
    .top{display:flex;justify-content:space-between;align-items:flex-start;gap:14px;flex-wrap:wrap;margin-bottom:14px}
    .title{font-weight:1000;font-size:34px;letter-spacing:.5px}
    .sub{color:var(--muted);font-weight:800;line-height:1.35}
    .pillRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
    .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);padding:10px 12px;border-radius:999px;background:rgba(255,255,255,.03);font-size:14px;color:var(--muted);white-space:nowrap}
    .pill b{color:var(--txt)}
    .pill.good{border-color:rgba(45,212,191,.35);background:rgba(45,212,191,.08)}
    .pill.warn{border-color:rgba(251,191,36,.35);background:rgba(251,191,36,.08)}
    .pill.bad{border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.08)}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:14px}
    @media(max-width:1200px){.grid{grid-template-columns:repeat(2,1fr)}}
    @media(max-width:720px){.grid{grid-template-columns:1fr}}
    .card{border:1px solid var(--line);border-radius:var(--r);background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));box-shadow:var(--shadow);padding:16px;min-height:130px}
    .pair{font-weight:1000;font-size:22px;line-height:1.15}
    .meta{margin-top:8px;color:var(--muted);font-weight:900;line-height:1.35}
    .code{display:inline-block;margin-top:10px;padding:8px 10px;border-radius:999px;border:1px solid rgba(45,212,191,.35);background:rgba(45,212,191,.10);color:var(--good);font-weight:1000}
    .footer{margin-top:14px;border:1px solid var(--line);border-radius:18px;background:rgba(255,255,255,.03);padding:14px;color:var(--muted);font-weight:900;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .big{font-size:18px;color:var(--txt)}
    .hidden{display:none !important;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .k{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);padding:7px 10px;border-radius:999px;background:rgba(255,255,255,.03);color:var(--muted);font-weight:900;font-size:12px}
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div style="min-width:280px">
      <div class="title">Now Matching ðŸ’š</div>
      <div class="sub">
        Aliases only â€¢ Sorted high â†’ low â€¢ Visible 3 hours â€¢ Rotates every 10s<br/>
        <span class="k">Only <b>Checked-In</b> guests appear here</span>
      </div>
    </div>

    <div class="pillRow" style="min-width:320px">
      <div class="pill"><b>Room</b> <span id="roomPill">â€”</span></div>
      <div class="pill"><b>Session</b> <span id="sessionPill">â€”</span></div>
      <div class="pill" id="venuePillWrap"><b>Venue</b> <span id="venuePill">â€”</span></div>

      <div class="pill" id="wsPillWrap"><b>WS</b> <span id="wsPill">DISCONNECTED</span></div>

      <div class="pill warn"><b>Expected</b> <span id="expectedPill">0</span></div>
      <div class="pill good"><b>Checked In</b> <span id="checkedInPill">0</span></div>
      <div class="pill good"><b>Active Matches</b> <span id="activeMatchesPill">0</span></div>
      <div class="pill" id="hotspotWrap"><b>Tonightâ€™s Hotspot</b> <span id="hotspotPill">â€”</span></div>
    </div>
  </div>

  <div class="grid" id="grid"></div>

  <div class="footer">
    <div class="big">See your alias pairing? Go to the host stand to connect.</div>
    <div>Barfly Social â€¢ Private Bar Matchmaking</div>
  </div>
</div>

<script>
/* ============================================================
   TV â€” CHECK-IN MODEL SUPPORT (v11)
   - Show matches ONLY when BOTH are checked-in
   - Prefer host-provided counts/hotspot, fallback when missing
============================================================ */

const WS_URL = "wss://bar-match-relay.onrender.com";
const ROTATE_MS = 10 * 1000;

const RESYNC_MS = 25 * 1000;
const RECONNECT_MS = 2500;

const HEARTBEAT_MS = 15 * 1000;
const STALE_MS = 45 * 1000;

const $ = (id)=>document.getElementById(id);

function qs(){
  const u=new URL(location.href);
  const q = Object.fromEntries(u.searchParams.entries());
  q.room = (q.room || q.roomId || q.barId || "").trim();
  q.session = (q.session || "").trim();
  q.venue = (q.venue || "").trim();
  return q;
}
function esc(s){
  return String(s??"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}
function normVenue(v){
  const s = String(v||"").trim();
  if(!s) return "";
  if(/^all$/i.test(s) || /^allvenues$/i.test(s) || s === "*") return "";
  return s;
}

/* =========================
   CONFIG (venue names)
========================= */
let HOST_CONFIG = null;

function barNameFromCfg(id){
  const clean = String(id||"").trim();
  if(!clean) return "";
  const b = (HOST_CONFIG?.bars || []).find(x => x.id === clean);
  return (b?.name || clean);
}
function labelVenue(id){
  const clean = String(id||"").trim();
  if(!clean) return "Venue";
  return barNameFromCfg(clean) || clean;
}
function applyVenuePillUI(){
  const q = qs();
  const v = normVenue(q.venue);
  const wrap = $("venuePillWrap");
  const pill = $("venuePill");

  if(!v){
    wrap.classList.add("hidden");
  }else{
    wrap.classList.remove("hidden");
    pill.textContent = labelVenue(v);
  }
}

/* =========================
   WS STATE
========================= */
let WS=null;
let WS_STATE="DISCONNECTED";
let matches=[];
let page=0;
let reconnectTimer=null;

let hbTimer=null;
let staleTimer=null;
let lastTrafficAt = Date.now();

let lastCountsAt = 0;

function setWsStatus(s){
  WS_STATE=s;
  $("wsPill").textContent=s;
  $("wsPillWrap").className = "pill " + (s==="CONNECTED"?"good": s==="CONNECTING"?"warn": s==="ERROR"?"bad":"");
}
function touchTraffic(){ lastTrafficAt = Date.now(); }

function safeSend(obj){
  try{
    if(WS && WS.readyState===WebSocket.OPEN){
      WS.send(JSON.stringify(obj));
      return true;
    }
  }catch{}
  return false;
}

function requestSync(){
  const q=qs();
  if(!q.room || !q.session) return;
  safeSend({ type:"request_tv_sync", roomId: q.room, room: q.room, barId: q.room, session: q.session });
}
function requestConfig(){
  const q=qs();
  if(!q.room || !q.session) return;
  safeSend({ type:"request_config", roomId: q.room, room: q.room, barId: q.room, session: q.session });
}

function heartbeatTick(){
  if(WS_STATE!=="CONNECTED") return;
  const q=qs();
  safeSend({ type:"ping", roomId: q.room, room: q.room, barId: q.room, session: q.session, t: Date.now() });
  if(Date.now() - lastTrafficAt > STALE_MS){
    try{ WS?.close(); }catch{}
  }
}
function startHeartbeat(){
  stopHeartbeat();
  touchTraffic();
  hbTimer = setInterval(heartbeatTick, HEARTBEAT_MS);
  staleTimer = setInterval(()=>{
    if(WS_STATE==="CONNECTED" && (Date.now()-lastTrafficAt)>STALE_MS){
      try{ WS?.close(); }catch{}
    }
  }, 5000);
}
function stopHeartbeat(){
  clearInterval(hbTimer); hbTimer=null;
  clearInterval(staleTimer); staleTimer=null;
}

/* =========================
   CHECK-IN FILTER + COUNTS
========================= */
function isCheckedInFlag(m, side){
  const isA = side==="a";
  const v1 = isA ? m.aCheckedIn : m.bCheckedIn;
  const v2 = isA ? m.checkedInA : m.checkedInB;
  const st = isA ? (m.aStatus || m.statusA) : (m.bStatus || m.statusB);

  if(typeof v1 === "boolean") return v1;
  if(typeof v2 === "boolean") return v2;
  if(typeof st === "string") return st.toLowerCase().includes("check");
  return true; // old host fallback
}
function filteredMatches(){
  const q=qs();
  const venue = normVenue(q.venue);
  const t = Date.now();

  let list = (matches || []).filter(m => !m.expiresAt || m.expiresAt > t);
  list = list.filter(m => isCheckedInFlag(m,"a") && isCheckedInFlag(m,"b"));

  if(venue){
    list = list.filter(m => (m.aVenueId === venue) || (m.bVenueId === venue));
  }

  list.sort((a,b)=>(b.score||0)-(a.score||0));
  return list;
}

function computeHotspotFromList(list){
  const counts = new Map();
  for(const m of list){
    const av = String(m.aVenueId||"").trim();
    const bv = String(m.bVenueId||"").trim();
    if(av) counts.set(av, (counts.get(av)||0)+1);
    if(bv) counts.set(bv, (counts.get(bv)||0)+1);
  }
  let bestId="", bestCount=0;
  for(const [id,c] of counts.entries()){
    if(c > bestCount){ bestId=id; bestCount=c; }
  }
  if(!bestId) return { id:"", label:"â€”" };
  return { id:bestId, label:`${labelVenue(bestId)} (${bestCount})` };
}

function setCountsFromMsg(msg){
  const c = msg.counts || msg.stats || msg.summary || {};

  const expected =
    (typeof c.expected === "number" ? c.expected :
    typeof c.pendingExpected === "number" ? c.pendingExpected :
    typeof msg.expected === "number" ? msg.expected : null);

  const checkedIn =
    (typeof c.checkedIn === "number" ? c.checkedIn :
    typeof c.arrived === "number" ? c.arrived :
    typeof msg.checkedIn === "number" ? msg.checkedIn : null);

  const activeMatches =
    (typeof c.activeMatches === "number" ? c.activeMatches :
    typeof c.tvActive === "number" ? c.tvActive :
    typeof msg.activeMatches === "number" ? msg.activeMatches : null);

  const hotspotLabel =
    (typeof c.hotspotLabel === "string" ? c.hotspotLabel :
     typeof c.hotspot === "string" ? c.hotspot :
     (c.hotspot && typeof c.hotspot === "object" && c.hotspot.label ? String(c.hotspot.label) : null));

  let changed = false;
  if(expected!=null){ $("expectedPill").textContent = String(expected); changed=true; }
  if(checkedIn!=null){ $("checkedInPill").textContent = String(checkedIn); changed=true; }
  if(activeMatches!=null){ $("activeMatchesPill").textContent = String(activeMatches); changed=true; }

  if(hotspotLabel!=null){
    $("hotspotPill").textContent = hotspotLabel || "â€”";
    changed=true;
  }

  if(changed) lastCountsAt = Date.now();
  return changed;
}

function setCountsFallback(){
  const active = filteredMatches();
  $("activeMatchesPill").textContent = String(active.length);

  // Expected/CheckedIn unknown without host counts; leave as-is.
  const hs = computeHotspotFromList(active);
  $("hotspotPill").textContent = hs.label;
}

/* =========================
   RENDER
========================= */
function formatAliasWithVenue(alias, venueId, showVenue){
  const a = alias || "Guest";
  if(!showVenue) return a;
  const v = String(venueId||"").trim();
  if(!v) return a;
  return `${a} @ ${labelVenue(v)}`;
}

function render(){
  const grid=$("grid");
  grid.innerHTML="";
  const list = filteredMatches();

  // âœ… Only fallback if host hasn't given counts recently
  if(Date.now() - lastCountsAt > 5000){
    setCountsFallback();
  }

  if(!list.length){
    grid.innerHTML = `
      <div class="card">
        <div class="pair">Waiting for checked-in matchesâ€¦</div>
        <div class="meta">
          No active matches in queue.<br/>
          <span class="k">Guests must be <b>Checked In</b> by the host to appear on TV.</span>
        </div>
      </div>
    `;
    return;
  }

  const q=qs();
  const isAllVenues = !normVenue(q.venue);

  const perPage = 9;
  const pages = Math.max(1, Math.ceil(list.length / perPage));
  page = page % pages;

  const slice = list.slice(page*perPage, page*perPage + perPage);
  for(const m of slice){
    const el=document.createElement("div");
    el.className="card";

    const left = formatAliasWithVenue(m.aAlias, m.aVenueId, isAllVenues);
    const right = formatAliasWithVenue(m.bAlias, m.bVenueId, isAllVenues);

    const bothVenues = isAllVenues && String(m.aVenueId||"").trim() && String(m.bVenueId||"").trim();
    const venuesLine = bothVenues
      ? `Venues: <span class="mono">${esc(labelVenue(m.aVenueId))}</span> + <span class="mono">${esc(labelVenue(m.bVenueId))}</span>`
      : "";

    el.innerHTML=`
      <div class="pair">${esc(left)} + ${esc(right)} â€” ${Math.round((m.score||0)*100)}%</div>
      <div class="meta">
        ${esc(m.plan || "See host to connect.")}
        ${venuesLine ? `<div style="margin-top:6px">${venuesLine}</div>` : ``}
      </div>
      <div class="code">Match Code: <span class="mono">${esc(m.code||"â€”")}</span></div>
    `;
    grid.appendChild(el);
  }
}

/* =========================
   CONNECT
========================= */
function scheduleReconnect(){
  clearTimeout(reconnectTimer);
  reconnectTimer = setTimeout(()=>connectWS(), RECONNECT_MS);
}

function connectWS(){
  const q=qs();
  $("roomPill").textContent=q.room || "â€”";
  $("sessionPill").textContent=q.session || "â€”";
  applyVenuePillUI();

  if(!q.room || !q.session){
    setWsStatus("ERROR");
    $("grid").innerHTML = `
      <div class="card">
        <div class="pair">Missing room/session</div>
        <div class="meta">TV link must include ?room=...&session=...</div>
      </div>
    `;
    return;
  }

  stopHeartbeat();
  try{ WS?.close(); }catch{}

  WS = new WebSocket(WS_URL);
  setWsStatus("CONNECTING");

  WS.onopen=()=>{
    setWsStatus("CONNECTED");
    touchTraffic();
    startHeartbeat();

    safeSend({ type:"join", role:"tv", roomId: q.room, room: q.room, barId: q.room, session: q.session });

    requestConfig();
    requestSync();
  };

  WS.onmessage=(ev)=>{
    touchTraffic();
    let msg; try{ msg=JSON.parse(ev.data); }catch{ return; }

    if(msg.type === "ping"){
      const q=qs();
      safeSend({ type:"pong", roomId: q.room, room: q.room, barId: q.room, session: q.session, t: Date.now() });
      return;
    }
    if(msg.type==="pong" || msg.type==="heartbeat" || msg.type==="pong_ack"){ return; }

    if(msg.type==="config" || msg.type==="event_config"){
      const q=qs();
      const msgRoom = (msg.roomId || msg.room || msg.barId || "").trim();
      if(msg.session && msg.session !== q.session) return;
      if(msgRoom && msgRoom !== q.room) return;

      HOST_CONFIG = msg;
      applyVenuePillUI();
      render();
      return;
    }

    if(msg.type==="tv_sync"){
      const q=qs();
      const msgRoom = (msg.roomId || msg.room || msg.barId || "").trim();
      if(msg.session && msg.session !== q.session) return;
      if(msgRoom && msgRoom !== q.room) return;

      matches = (msg.matches || []).map(m=>({
        score: m.score || 0,
        code: m.code || "",
        plan: m.plan || "",
        expiresAt: m.expiresAt || 0,

        aAlias: m.aAlias || m.a || m.aliasA || "",
        bAlias: m.bAlias || m.b || m.aliasB || "",

        aVenueId: m.aVenueId || "",
        bVenueId: m.bVenueId || "",

        aCheckedIn: (typeof m.aCheckedIn === "boolean") ? m.aCheckedIn : (typeof m.checkedInA === "boolean" ? m.checkedInA : undefined),
        bCheckedIn: (typeof m.bCheckedIn === "boolean") ? m.bCheckedIn : (typeof m.checkedInB === "boolean" ? m.checkedInB : undefined),
        aStatus: m.aStatus || m.statusA || "",
        bStatus: m.bStatus || m.statusB || ""
      }));

      setCountsFromMsg(msg);

      page = 0;
      render();
    }
  };

  WS.onerror=()=>{
    setWsStatus("ERROR");
    try{ WS?.close(); }catch{}
  };

  WS.onclose=()=>{
    setWsStatus("DISCONNECTED");
    stopHeartbeat();
    scheduleReconnect();
  };
}

/* rotate + periodic resync */
setInterval(()=>{ page++; render(); }, ROTATE_MS);
setInterval(()=>{ if(WS_STATE==="CONNECTED") requestSync(); }, RESYNC_MS);

connectWS();
render();
</script>
</body>
</html>








