<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Barfly Social — Host Dashboard</title>
  <style>
    :root{
      --bg:#0b0f1a; --card:#111a2b; --txt:#e9f0ff; --muted:#a7b3d1; --line:rgba(255,255,255,.12);
      --good:#2dd4bf; --bad:#fb7185; --warn:#fbbf24; --brand:#60a5fa; --shadow:0 10px 30px rgba(0,0,0,.35); --r:18px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:
      radial-gradient(1200px 800px at 20% -10%, rgba(96,165,250,.20), transparent 60%),
      radial-gradient(900px 700px at 110% 10%, rgba(45,212,191,.18), transparent 55%),
      var(--bg);
      color:var(--txt);
    }
    .wrap{max-width:1400px;margin:0 auto;padding:18px}
    .topbar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:14px;border:1px solid var(--line);border-radius:var(--r);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));box-shadow:var(--shadow);position:sticky;top:10px;z-index:10;backdrop-filter:blur(10px)}
    .left{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .brand{display:flex;gap:10px;align-items:center;line-height:1.1;padding:6px 10px;border-radius:14px;border:1px solid var(--line);background:rgba(255,255,255,.03)}
    .logo{
      width:34px;height:34px;border-radius:10px;border:1px solid var(--line);
      background:rgba(0,0,0,.18);object-fit:contain;display:block;
    }
    .brandText{display:flex;flex-direction:column}
    .brand .t{font-weight:1000;letter-spacing:.3px;font-size:18px}
    .brand .s{font-size:12px;color:var(--muted);font-weight:800}
    .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);padding:9px 10px;border-radius:999px;background:rgba(255,255,255,.03);font-size:13px;color:var(--muted);white-space:nowrap}
    .pill b{color:var(--txt);font-weight:1000}
    .btn{border:1px solid var(--line);background:rgba(255,255,255,.06);color:var(--txt);padding:11px 12px;border-radius:14px;font-weight:900;cursor:pointer;display:inline-flex;gap:8px;align-items:center;justify-content:center;user-select:none}
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.08)}
    .btn:active{transform:translateY(0)}
    .btn.primary{background:rgba(96,165,250,.20);border-color:rgba(96,165,250,.35)}
    .btn.good{background:rgba(45,212,191,.16);border-color:rgba(45,212,191,.35)}
    .btn.bad{background:rgba(251,113,133,.16);border-color:rgba(251,113,133,.35)}
    .btn.warn{background:rgba(251,191,36,.12);border-color:rgba(251,191,36,.35)}
    .btn.small{padding:9px 10px;font-size:13px;border-radius:12px}
    .grid{display:grid;gap:12px;grid-template-columns:1.25fr .75fr;margin-top:12px}
    @media(max-width:1100px){.grid{grid-template-columns:1fr}.topbar{position:static}}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));border:1px solid var(--line);border-radius:var(--r);box-shadow:var(--shadow);padding:14px}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media(max-width:720px){.two{grid-template-columns:1fr}}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .hr{height:1px;background:var(--line);margin:12px 0}
    label{font-size:13px;color:var(--muted);font-weight:900}
    input,select{width:100%;padding:12px 12px;border-radius:14px;border:1px solid var(--line);background:rgba(0,0,0,.25);color:var(--txt);outline:none;font-size:16px}
    .muted{color:var(--muted)}
    .list{display:flex;flex-direction:column;gap:8px}
    .item{display:flex;justify-content:space-between;align-items:flex-start;gap:10px;padding:12px;border-radius:16px;border:1px solid var(--line);background:rgba(0,0,0,.20);overflow:hidden}
    .item strong{display:block;font-size:15px;font-weight:1000}
    .sub{font-size:13px;color:var(--muted);line-height:1.35}
    .badge{border:1px solid var(--line);padding:7px 9px;border-radius:999px;font-size:12px;color:var(--muted);white-space:nowrap;font-weight:900}
    .badge.good{color:var(--good);border-color:rgba(45,212,191,.35);background:rgba(45,212,191,.10)}
    .badge.bad{color:var(--bad);border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.10)}
    .badge.warn{color:var(--warn);border-color:rgba(251,191,36,.35);background:rgba(251,191,36,.10)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:rgba(17,26,43,.92);border:1px solid var(--line);border-radius:18px;padding:12px;box-shadow:var(--shadow);display:none;max-width:92vw;z-index:60}
    .toast .t{font-weight:1000;margin-bottom:2px}
    .toast .m{font-size:13px;color:var(--muted)}
    .hidden{display:none !important;}
    .mini{font-size:12px;color:var(--muted);font-weight:900}
    .kbd{
      border:1px solid var(--line);
      padding:7px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-weight:900;
      font-size:12px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }

    /* QR modal */
    .modalBack{
      position:fixed; inset:0; background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center; padding:16px; z-index:80;
    }
    .modal{
      width:min(520px, 94vw);
      border:1px solid var(--line); border-radius:22px;
      background:linear-gradient(180deg, rgba(17,26,43,.98), rgba(17,26,43,.92));
      box-shadow:var(--shadow);
      padding:14px;
    }
    .modalTop{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .modalTitle{font-weight:1000;font-size:18px}
    .qrBox{
      margin-top:12px; display:flex; gap:12px; flex-wrap:wrap; align-items:center;
      border:1px solid var(--line); border-radius:18px; padding:12px; background:rgba(0,0,0,.18);
    }
    .qrImg{width:260px;height:260px;border-radius:14px;border:1px solid var(--line);background:#0a1020;object-fit:contain}
    .modalSmall{color:var(--muted);font-weight:900;font-size:12px;line-height:1.35;max-width:200px}
    .modalLink{margin-top:10px; font-size:12px; color:var(--muted); word-break:break-all}
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="left">
      <div class="brand">
        <!-- If /logo.png exists in your deploy, it will show. If not, it just looks like a neat placeholder. -->
        <img class="logo" id="brandLogo" alt="Barfly logo" src="/logo.png" onerror="this.style.display='none'">
        <div class="brandText">
          <div class="t">Barfly Social</div>
          <div class="s">Host Dashboard • Phone Check-In</div>
        </div>
      </div>

      <div class="pill"><b>Room</b> <span id="roomPill" class="mono">—</span></div>
      <div class="pill"><b>Session</b> <span id="sessionPill" class="mono">—</span></div>
      <div class="pill"><b>WS</b> <span id="wsPill" class="mono">DISCONNECTED</span></div>

      <div class="pill"><b>Min Match</b> <span id="minMatchPill">75%</span></div>
      <div class="pill"><b>Hotspot</b> <span id="hotspotPill">—</span></div>
      <div class="pill" id="pinPillWrap"><b>Host Lock</b> <span id="pinPill">ON</span></div>
    </div>

    <div class="left">
      <button class="btn small primary" id="btnCopyJoin">Copy Join Link</button>
      <button class="btn small primary" id="btnShowJoinQR">Join QR</button>
      <button class="btn small warn" id="btnCopyTV">Copy TV Link</button>
      <button class="btn small warn" id="btnShowTVQR">TV QR</button>
      <button class="btn small good" id="btnExport">Export CSV</button>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>Event Setup</h2>
      <div class="muted">
        Guests submit an <b>expected</b> location. At arrival, host verifies with <b>phone number</b> and assigns/checks-in the guest.
        <br><span class="kbd">Rule</span> <span class="mini">TV matches require: mutual like + score ≥ min + both checked in.</span>
      </div>
      <div class="hr"></div>

      <div class="two">
        <div>
          <label>Mode</label>
          <select id="modeSelect">
            <option value="single" selected>Single Location</option>
            <option value="city">City-Wide Event</option>
          </select>
        </div>

        <div>
          <label>Session code</label>
          <div class="row">
            <input id="sessionCode" class="mono">
            <button class="btn primary" id="btnNewSession" type="button">New</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="two">
        <div>
          <label>Locations (Bars)</label>
          <select id="barSelect"></select>

          <div class="row" style="margin-top:8px">
            <input id="newBarName" placeholder="e.g., The Brickyard">
            <button class="btn primary" id="btnAddBar" type="button">Add</button>
          </div>

          <div class="row" style="margin-top:8px">
            <button class="btn bad small" id="btnDeleteBar" type="button">Delete bar</button>
            <button class="btn warn small" id="btnClearRoster" type="button">Clear roster</button>
          </div>

          <div class="mini" style="margin-top:8px">
            Tip: In City mode, double-click the dropdown to toggle “participating” for the selected bar.
          </div>
        </div>

        <div>
          <label>City Event</label>
          <div class="row">
            <input id="eventName" placeholder="e.g., Baton Rouge Barfly Night">
            <button class="btn primary" id="btnCreateEvent" type="button">Create/Update</button>
          </div>

          <div class="mini" style="margin-top:8px">Participating locations (only these appear in guest dropdown):</div>
          <div class="list" id="eventBars"></div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <button class="btn primary" id="btnRefresh" type="button">Refresh View</button>
        <button class="btn good" id="btnComputeMutuals" type="button">Compute Mutuals → TV</button>
        <button class="btn warn" id="btnBroadcastConfig" type="button">Broadcast Config</button>
        <button class="btn small" id="btnHostPin" type="button">Set/Unlock Host PIN</button>
      </div>

      <div class="hr"></div>

      <div class="two">
        <div>
          <label>Search alias (filters Arrivals + Checked-In)</label>
          <input id="searchAlias" placeholder="Type 2–3 letters… (press Esc to clear)">
          <div class="mini" style="margin-top:6px">Filters the lists below (alias only).</div>
        </div>
        <div>
          <label>Search helper</label>
          <div class="row">
            <button class="btn small" id="btnClearSearch" type="button">Clear Search</button>
            <span class="pill"><b>Filter</b> <span id="filterPill">OFF</span></span>
          </div>
          <div class="mini" style="margin-top:6px">Shows only aliases that match your search.</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="two">
        <div>
          <h3>Phone Check-In (Recommended)</h3>
          <div class="mini">Ask guest for phone → enter 10 digits → choose where they are standing → Check In.</div>
          <div class="row" style="margin-top:8px">
            <input id="checkinPhone" inputmode="numeric" placeholder="Phone (10 digits)">
            <button class="btn good" id="btnPhoneCheckin" type="button">Check In</button>
          </div>
          <div class="row" style="margin-top:8px">
            <select id="checkinVenue"></select>
            <span class="kbd">Host assigns venue</span>
          </div>
          <div class="mini" style="margin-top:8px">
            If multiple guests share a phone (rare), you’ll be prompted to pick the alias.
          </div>
        </div>

        <div>
          <h3>Manual (Fallback)</h3>
          <div class="mini">Use alias search + buttons if phone wasn’t captured on submit.</div>
          <div class="mini" style="margin-top:8px">
            Tip: manual actions use the <b>Check-In Venue</b> dropdown (no bar IDs required).
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="two">
        <div>
          <h3>Arrivals Queue (Pending • A→Z)</h3>
          <div class="mini">Guests appear after submit. Check them in when they arrive.</div>
          <div class="list" id="arrivals"></div>

          <div class="hr"></div>

          <h3>Checked In</h3>
          <div class="mini">Only <b>checked-in</b> mutuals can appear on TV.</div>
          <div class="list" id="checkedIn"></div>
        </div>

        <div>
          <h3>Venue Counts (Option C Hybrid)</h3>
          <div class="mini">Expected = pending who selected venue • Checked In = host verified • Active Matches = TV pairs involving that venue</div>
          <div class="list" id="venueCounts"></div>

          <div class="hr"></div>

          <h3>TV Queue (Active)</h3>
          <div class="mini">Active = both sides checked in + mutual like + score ≥ min.</div>
          <div class="list" id="tvQueue"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Status</h2>
      <div class="hr"></div>

      <div class="item">
        <div style="min-width:0">
          <strong>WebSocket Relay</strong>
          <div class="sub mono" id="wsUrlTxt">—</div>
        </div>
        <div class="badge" id="wsBadge">—</div>
      </div>

      <div class="hr"></div>

      <h3>Quick Links</h3>
      <div class="list">
        <div class="item">
          <div style="min-width:0">
            <strong>Join</strong>
            <div class="sub mono" id="joinLink">—</div>
          </div>
          <button class="btn small primary" id="btnCopyJoin2" type="button">Copy</button>
        </div>
        <div class="item">
          <div style="min-width:0">
            <strong>TV</strong>
            <div class="sub mono" id="tvLink">—</div>
          </div>
          <button class="btn small warn" id="btnCopyTV2" type="button">Copy</button>
        </div>
      </div>

      <div class="hr"></div>

      <h3>Totals</h3>
      <div class="two">
        <div>
          <div class="muted">Expected (pending)</div>
          <div style="font-size:30px;font-weight:1000" id="countExpected">0</div>
        </div>
        <div>
          <div class="muted">Checked In</div>
          <div style="font-size:30px;font-weight:1000" id="countCheckedIn">0</div>
        </div>
      </div>

      <div class="two" style="margin-top:10px">
        <div>
          <div class="muted">Active TV Matches</div>
          <div style="font-size:30px;font-weight:1000" id="countTV">0</div>
        </div>
        <div>
          <div class="muted">Joined (all)</div>
          <div style="font-size:30px;font-weight:1000" id="countJoined">0</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="muted" style="font-weight:900;line-height:1.35">
        If guests say “Waiting for host config,” confirm:<br>
        1) Host is open and <b>WS shows CONNECTED</b><br>
        2) The guest link uses the <b>same room + session</b> shown in the pills above
      </div>
    </div>
  </div>

  <div class="toast" id="toast">
    <div class="t" id="toastT">Updated</div>
    <div class="m" id="toastM">—</div>
  </div>
</div>

<!-- QR modal -->
<div class="modalBack" id="qrBack" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="modalTop">
      <div class="modalTitle" id="qrTitle">QR Code</div>
      <button class="btn small" id="btnCloseQR" type="button">Close</button>
    </div>
    <div class="qrBox">
      <img class="qrImg" id="qrImg" alt="QR code">
      <div class="modalSmall">
        Point your phone camera at the QR code to open the link.
        <div style="margin-top:10px" class="mini">
          Pro tip: Use <b>Join QR</b> on flyers, and <b>TV QR</b> for the screen operator.
        </div>
      </div>
    </div>
    <div class="modalLink mono" id="qrLinkTxt">—</div>
  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const WS_URL = "wss://bar-match-relay.onrender.com";
const MIN_MATCH_SCORE = 0.75;
const TV_EXPIRE_MS = 3 * 60 * 60 * 1000;
const TV_ROTATE_MS = 10 * 1000;

const HEARTBEAT_MS = 15 * 1000;
const PONG_TIMEOUT_MS = 45 * 1000;
const RECONNECT_BASE_MS = 800;
const RECONNECT_MAX_MS  = 10 * 1000;

const STORAGE = {
  BARS: "bm_bars_v12",
  HOST: "bm_host_v12",
  PEOPLE: "bm_people_v12",
  LIKES: "bm_likes_v12",
  EVENT: "bm_event_v12",
  TV: "bm_tv_v12",
  DEDUPE: "bm_dedupe_v12",
  CONTACTS: "bm_contacts_v12",
  UI: "bm_ui_v12",
  HOSTPIN: "bm_host_pin_v12"
};

const $ = (id)=>document.getElementById(id);
function esc(s){ return String(s??"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;"," >":"&gt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c])); }
function now(){ return Date.now(); }
function showToast(t,m){
  $("toastT").textContent=t; $("toastM").textContent=m;
  const el=$("toast"); el.style.display="block";
  clearTimeout(showToast._t);
  showToast._t=setTimeout(()=>{el.style.display="none"}, 2600);
}
function uid(){ return (crypto?.randomUUID?.() || ("id_"+Math.random().toString(16).slice(2)+"_"+Math.random().toString(16).slice(2))); }
function genSession(){ return Math.random().toString(36).slice(2,6).toUpperCase()+"-"+Math.random().toString(36).slice(2,6).toUpperCase(); }

function loadJSON(key, fallback){
  try{ return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); }catch{ return fallback; }
}
function saveJSON(key, val){ localStorage.setItem(key, JSON.stringify(val)); }

function digitsOnly(s){ return String(s||"").replace(/\D/g,""); }
function phoneLast4(s){
  const d = digitsOnly(s);
  if(d.length < 4) return "";
  return d.slice(-4);
}

/* =========================
   HOST PIN (light lock)
========================= */
let hostPin = (localStorage.getItem(STORAGE.HOSTPIN) || "").trim();
let hostUnlocked = false;

function pinHash(str){
  const s = String(str||"");
  let h=2166136261;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
  return "h"+(h>>>0).toString(16);
}
function setPinPill(){
  $("pinPill").textContent = hostPin ? (hostUnlocked ? "UNLOCKED" : "LOCKED") : "OFF";
  $("pinPillWrap").className = "pill" + (hostPin ? (hostUnlocked ? " good":" warn") : "");
}
function requireUnlock(){
  if(!hostPin) return true;
  if(hostUnlocked) return true;
  const attempt = prompt("Host PIN required:", "");
  if(!attempt) return false;
  if(pinHash(attempt) === hostPin){
    hostUnlocked = true;
    setPinPill();
    showToast("Unlocked","Host controls unlocked.");
    return true;
  }
  showToast("Denied","Incorrect PIN.");
  return false;
}
function handlePinButton(){
  const cur = hostPin ? prompt("Enter current PIN to change/unlock (or Cancel):", "") : null;
  if(hostPin){
    if(!cur) { return requireUnlock(); }
    if(pinHash(cur) !== hostPin){
      showToast("Denied","Incorrect PIN.");
      return;
    }
  }
  const next = prompt("Set a NEW PIN (4-8 digits). Leave blank to turn OFF:", "");
  if(!next){
    hostPin = "";
    localStorage.removeItem(STORAGE.HOSTPIN);
    hostUnlocked = false;
    setPinPill();
    showToast("PIN","Host PIN turned OFF.");
    return;
  }
  const d = digitsOnly(next);
  if(d.length < 4 || d.length > 8){
    showToast("PIN","Use 4–8 digits.");
    return;
  }
  hostPin = pinHash(d);
  localStorage.setItem(STORAGE.HOSTPIN, hostPin);
  hostUnlocked = true;
  setPinPill();
  showToast("PIN","Host PIN set and unlocked.");
}

/* =========================
   UI STATE (search)
========================= */
let ui = loadJSON(STORAGE.UI, { search:"" });
function setSearch(val){
  ui.search = String(val||"");
  saveJSON(STORAGE.UI, ui);
  const q = ui.search.trim();
  $("filterPill").textContent = q ? `"${q}"` : "OFF";
}
function matchSearch(alias){
  const q = (ui.search||"").trim().toLowerCase();
  if(!q) return true;
  return String(alias||"").toLowerCase().includes(q);
}

/* =========================
   STATE
========================= */
let bars = loadJSON(STORAGE.BARS, []);
let host = loadJSON(STORAGE.HOST, { mode:"single", activeBarId:null, session: genSession() });
let people = loadJSON(STORAGE.PEOPLE, []);
let likes  = loadJSON(STORAGE.LIKES, {});
let contacts = loadJSON(STORAGE.CONTACTS, {});
let event  = loadJSON(STORAGE.EVENT, { eventId:"", name:"", participatingBarIds:[] });
let tv     = loadJSON(STORAGE.TV, { matches:[] });
let dedupe = loadJSON(STORAGE.DEDUPE, {});

/* =========================
   BARS
========================= */
function ensureDefaultBar(){
  if(!bars.length){
    const id = uid();
    bars = [{id, name:"Default Bar"}];
    saveJSON(STORAGE.BARS, bars);
  }
  if(!host.activeBarId) host.activeBarId = bars[0].id;
  if(!event.eventId){
    event.eventId = "CITY-"+uid().slice(0,6).toUpperCase();
    saveJSON(STORAGE.EVENT, event);
  }
}
function barName(id){ return bars.find(b=>b.id===id)?.name || (id ? id : "—"); }

function participatingSet(){
  return new Set((event.participatingBarIds || []).filter(id => bars.some(b=>b.id===id)));
}
function isVenueAllowed(venueId){
  const v = String(venueId||"").trim();
  if(!v) return true;
  if(host.mode !== "city") return true;
  const set = participatingSet();
  if(set.size === 0) return true;
  return set.has(v);
}

function populateCheckinVenueSelect(){
  const sel = $("checkinVenue");
  if(!sel) return;
  sel.innerHTML = "";
  for(const b of bars){
    const opt = document.createElement("option");
    opt.value = b.id;
    opt.textContent = b.name;
    if(b.id === host.activeBarId) opt.selected = true;
    sel.appendChild(opt);
  }
}

/* =========================
   WS + HEARTBEAT
========================= */
let WS=null;
let WS_STATE="DISCONNECTED";
let lastTrafficAt = 0;
let lastPongAt = 0;
let reconnectAttempts = 0;

const timers = { tvPurge:null, rebroadcastConfig:null, rosterSync:null, heartbeat:null, health:null };

function wsSetStatus(s){
  WS_STATE=s;
  $("wsPill").textContent = s;
  const ageSec = lastTrafficAt ? Math.max(0, Math.round((now()-lastTrafficAt)/1000)) : null;
  const label = (s==="CONNECTED" && ageSec!=null) ? `CONNECTED • ${ageSec}s` : (s==="CONNECTED" ? "CONNECTED" : s);
  $("wsBadge").textContent = label;
  $("wsBadge").className = "badge" + (s==="CONNECTED"?" good": s==="CONNECTING"?" warn": s==="ERROR"?" bad":"");
}
function safeSend(obj){
  try{
    if(WS && WS.readyState===WebSocket.OPEN){
      WS.send(JSON.stringify(obj));
      return true;
    }
  }catch{}
  return false;
}
function currentRoomId(){
  return (host.mode === "city") ? event.eventId : host.activeBarId;
}

/* =========================
   CONFIG BROADCAST
========================= */
function broadcastConfig(){
  const roomId = currentRoomId();
  const participatingIds = Array.from(participatingSet());
  safeSend({
    type: "config",
    roomId, room: roomId, barId: roomId,
    session: host.session,
    mode: host.mode,
    event: { eventId: event.eventId, name: event.name || "" },
    bars: bars.map(b => ({ id:b.id, name:b.name })),
    participatingBarIds: participatingIds,
    rules: {
      minMatch: MIN_MATCH_SCORE,
      tvExpireMs: TV_EXPIRE_MS,
      tvRotateMs: TV_ROTATE_MS,
      checkIn: "phone_or_manual_host_only",
      venueChange: "host_only"
    },
    hostLock: hostPin ? "pin_enabled" : "off"
  });
}

/* =========================
   POOL + ROSTER SYNC
========================= */
function activePool(){
  const roomId = currentRoomId();
  return people.filter(p => p.session === host.session && p.roomId === roomId && p.status !== "removed");
}
function broadcastRosterSync(requesterNonce=null){
  const roomId = currentRoomId();
  const pool = activePool();
  const roster = pool.map(p => ({
    id: p.id,
    alias: p.alias,
    venueId: p.expectedVenueId || p.venueId || "",
    status: p.status || "pending"
  }));
  const you = requesterNonce ? pool.find(p => p.clientNonce === requesterNonce || p.id === requesterNonce) : null;

  safeSend({
    type: "roster_sync",
    roomId, room: roomId, barId: roomId,
    session: host.session,
    roster,
    people: roster,
    you: you ? { id: you.id, alias: you.alias, venueId: you.expectedVenueId || "", status: you.status || "pending" } : undefined
  });
}

function stopHeartbeat(){
  if(timers.heartbeat){ clearInterval(timers.heartbeat); timers.heartbeat=null; }
  if(timers.health){ clearInterval(timers.health); timers.health=null; }
}
function startHeartbeat(){
  stopHeartbeat();
  lastTrafficAt = now();
  lastPongAt = now();

  timers.heartbeat = setInterval(()=>{
    if(WS_STATE!=="CONNECTED") return;
    const roomId = currentRoomId();
    safeSend({ type:"ping", roomId, room: roomId, barId: roomId, session: host.session, t: now() });
  }, HEARTBEAT_MS);

  timers.health = setInterval(()=>{
    if(WS_STATE!=="CONNECTED") return;
    const silentFor = now() - Math.max(lastPongAt||0, lastTrafficAt||0);
    if(silentFor > PONG_TIMEOUT_MS){
      wsSetStatus("ERROR");
      try{ WS?.close(); }catch{}
      scheduleReconnect();
    }else{
      wsSetStatus("CONNECTED");
    }
  }, 1000);
}
function cleanupWs(){
  stopHeartbeat();
  try{
    WS && (WS.onopen = WS.onmessage = WS.onerror = WS.onclose = null);
    if(WS && (WS.readyState===WebSocket.OPEN || WS.readyState===WebSocket.CONNECTING)) WS.close();
  }catch{}
  WS=null;
}
function scheduleReconnect(){
  cleanupWs();
  const jitter = Math.floor(Math.random()*250);
  const backoff = Math.min(RECONNECT_MAX_MS, RECONNECT_BASE_MS * Math.pow(2, reconnectAttempts));
  const wait = backoff + jitter;
  reconnectAttempts = Math.min(10, reconnectAttempts+1);
  setTimeout(()=>wsConnect(true), wait);
}

/* =========================
   SUBMISSION + DEDUPE
========================= */
function normalizeIncomingPayload(msg){
  const p = msg?.payload || (msg?.type==="submit_payload" ? msg.payload : null);
  if(p) return p;
  if(msg?.type==="submit_payload" && !msg.payload){
    const copy = {...msg};
    delete copy.type;
    return copy;
  }
  return null;
}
function payloadRoomSessionOk(payload){
  const room = payload?.roomId ?? payload?.room ?? payload?.barId ?? "";
  const session = payload?.session ?? "";
  if(session && session !== host.session) return false;
  if(room && room !== currentRoomId()) return false;
  return true;
}
function payloadFingerprint(payload){
  const obj = {
    room: payload?.roomId ?? payload?.room ?? payload?.barId ?? "",
    session: payload?.session ?? "",
    clientNonce: payload?.clientNonce ?? "",
    venueId: payload?.venueId ?? payload?.expectedVenueId ?? "",
    travelYes: !!payload?.travelYes,
    identityPhone: digitsOnly(payload?.identityPhone || payload?.contactPhone || payload?.contact?.phone || payload?.attrs?.identityPhone || ""),
    attrs: payload?.attrs ?? {},
    food: (payload?.foodChips ?? []).slice().sort(),
    act: (payload?.activityChips ?? []).slice().sort(),
    firstLoc: payload?.firstDateLoc ?? "",
    firstAvail: payload?.firstDateAvail ?? "",
    pays: payload?.pays ?? "",
    budget: payload?.budget ?? "",
    blurb: payload?.publicBlurb ?? "",
    starter: payload?.starter ?? ""
  };
  const s = JSON.stringify(obj);
  let h=2166136261;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
  return "fp_" + (h>>>0).toString(16);
}
function dedupeSeen(fp){
  const cutoff = now() - 10*60*1000;
  for(const k in dedupe){ if(dedupe[k] < cutoff) delete dedupe[k]; }
  if(dedupe[fp]) return true;
  dedupe[fp] = now();
  saveJSON(STORAGE.DEDUPE, dedupe);
  return false;
}
function ackSubmit(clientNonce=null){
  const roomId = currentRoomId();
  safeSend({ type: "submit_ack", roomId, room: roomId, barId: roomId, session: host.session, clientNonce: clientNonce || undefined });
}

/* =========================
   MATCH / SCORE
========================= */
const CODE_WORDS = ["LIME","WAVE","NOVA","GOLD","MOON","JAZZ","ROSE","BAYOU","SPARK","VIBE","MINT","ONYX","SUGAR","VELVET","NEON"];
function makeMatchCode(){
  const w = CODE_WORDS[Math.floor(Math.random()*CODE_WORDS.length)];
  const n = Math.floor(Math.random()*90)+10;
  return `${w}-${n}`;
}
function pairKey(aId,bId){ return aId < bId ? `${aId}::${bId}` : `${bId}::${aId}`; }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function overlapScore(arrA, arrB){
  const A = Array.from(new Set(arrA || []));
  const B = new Set(arrB || []);
  if(A.length===0 || B.size===0) return 0;
  let inter=0;
  for(const x of A) if(B.has(x)) inter++;
  return inter / Math.max(1, Math.min(A.length, B.size));
}
function bandContainsAge(band, age){
  if(!band || band==="Any") return true;
  if(band==="55+") return age>=55;
  const m = band.match(/(\d+)\D+(\d+)/);
  if(!m) return true;
  const lo = parseInt(m[1],10), hi=parseInt(m[2],10);
  return age>=lo && age<=hi;
}
function meetsHardFilters(A,B){
  const P = A.prefs || {};
  const D = A.deal || {};
  const attr = B.attrs || {};
  function hard(field){
    const pref = P[field];
    const isDeal = D[field] === true;
    if(!isDeal) return true;
    if(pref === "Any") return true;
    if(field==="ageBand") return bandContainsAge(pref, attr.age);
    return pref === attr[field];
  }
  return hard("ageBand") &&
    ["sex","race","income","height","build","eye","hair","skin","smoke","marital","politics","intent","family","edu","love","pets","religion"]
    .every(f=>hard(f));
}
function ageCompat(A,B){
  const aOk = bandContainsAge(A?.prefs?.ageBand, B?.attrs?.age);
  const bOk = bandContainsAge(B?.prefs?.ageBand, A?.attrs?.age);
  return (aOk && bOk) ? 1 : (aOk || bOk) ? 0.6 : 0;
}
function preferenceScore(A,B){
  const P = A.prefs || {};
  const attr = B.attrs || {};
  let used=0, good=0;
  const fields = ["sex","race","income","height","build","eye","hair","skin","smoke","marital","politics","intent","family","edu","love","pets","religion"];
  for(const f of fields){
    if(P[f] && P[f] !== "Any"){ used++; if(P[f] === attr[f]) good++; }
  }
  if(P.ageBand){ used++; if(bandContainsAge(P.ageBand, attr.age)) good++; }
  if(used===0) return 0.5;
  return good/used;
}
function interestsScore(A,B){
  const food = overlapScore(A.foodChips, B.foodChips);
  const act  = overlapScore(A.activityChips, B.activityChips);
  return clamp01(0.45*food + 0.55*act);
}
function scorePair(A,B){
  if(!meetsHardFilters(A,B)) return -999;
  const age = ageCompat(A,B);
  const intr = interestsScore(A,B);
  const prefs = preferenceScore(A,B);
  return clamp01(0.30*age + 0.40*intr + 0.30*prefs);
}
function travelPlan(A,B){
  const aVenue = A.checkedInVenueId || A.expectedVenueId || A.venueId;
  const bVenue = B.checkedInVenueId || B.expectedVenueId || B.venueId;
  const same = aVenue === bVenue;
  if(same) return { allowed:true, plan:`Meet at: ${barName(aVenue)} (same location)` };
  const aYes = !!A.travelYes, bYes = !!B.travelYes;
  if(!aYes && !bYes) return { allowed:false, plan:"No cross-location match (both chose No travel)" };
  if(aYes && !bYes)  return { allowed:true, plan:`Traveler goes to: ${barName(bVenue)} (A travels)` };
  if(!aYes && bYes)  return { allowed:true, plan:`Traveler goes to: ${barName(aVenue)} (B travels)` };
  return { allowed:true, plan:`Either can travel — check host stand to pick meetup bar` };
}

/* =========================
   LIKES / MUTUALS
========================= */
function ensureLikes(voterId){ if(!likes[voterId]) likes[voterId] = {}; }
function getLike(aId,bId){ return likes?.[aId]?.[bId]; }
function isMutual(aId,bId){ return getLike(aId,bId)===true && getLike(bId,aId)===true; }

/* =========================
   IMPORT GUEST
========================= */
const ALIAS_A = ["Neon","Velvet","Midnight","Lucky","Smooth","Wild","Golden","Sugar","Cosmic","Electric","Bayou","Rouge","Moon","Star","Cajun","Whisper","Spicy","Satin","Honey","Silver"];
const ALIAS_B = ["Muse","Wink","Charm","Heartbeat","Vibe","Spark","Sway","Crush","Flirt","Serenade","Rendezvous","Rose","Phoenix","Echo","Breeze","Glow","Nova","Julep","Daiquiri","Shot"];
function makeAlias(){
  const a = ALIAS_A[Math.floor(Math.random()*ALIAS_A.length)];
  const b = ALIAS_B[Math.floor(Math.random()*ALIAS_B.length)];
  const n = Math.floor(Math.random()*90)+10;
  return `${a}${b}${n}`;
}
function upsertGuestById(id, patch){
  const idx = people.findIndex(p=>p.id===id);
  if(idx>=0) people[idx] = { ...people[idx], ...patch };
  else people.push(patch);
  saveJSON(STORAGE.PEOPLE, people);
}
function extractIdentityPhone(payload, stableId){
  const direct = digitsOnly(payload?.identityPhone || "");
  if(direct.length===10) return direct;

  const c1 = digitsOnly(payload?.contactPhone || "");
  if(c1.length===10) return c1;

  const c2 = digitsOnly(payload?.contact?.phone || "");
  if(c2.length===10) return c2;

  const c3 = digitsOnly(payload?.attrs?.identityPhone || "");
  if(c3.length===10) return c3;

  const stored = digitsOnly(contacts?.[stableId]?.phone || "");
  if(stored.length===10) return stored;

  return "";
}

function importGuest(payload){
  const incomingRoom = payload.roomId ?? payload.room ?? payload.barId ?? payload.roomID ?? "";
  const stableId = (payload.clientNonce && String(payload.clientNonce).trim()) ? String(payload.clientNonce).trim() : uid();
  const existing = people.find(p=>p.id===stableId);
  const expectedVenue = payload.expectedVenueId || payload.venueId || "";

  const identityPhone = extractIdentityPhone(payload, stableId);

  const p = {
    id: stableId,
    clientNonce: payload.clientNonce || (existing?.clientNonce || null),
    alias: existing?.alias || makeAlias(),
    roomId: incomingRoom || currentRoomId(),
    session: payload.session,

    expectedVenueId: expectedVenue,
    checkedInVenueId: existing?.checkedInVenueId || "",
    status: existing?.status || "pending",
    travelYes: !!payload.travelYes,

    identityPhone: identityPhone || (existing?.identityPhone || ""),

    attrs: payload.attrs || {},
    prefs: payload.prefs || {},
    deal: payload.deal || {},
    foodChips: payload.foodChips || [],
    activityChips: payload.activityChips || [],
    firstDateLoc: payload.firstDateLoc || "",
    firstDateAvail: payload.firstDateAvail || "",
    publicBlurb: payload.publicBlurb || "",
    starter: payload.starter || "",
    pays: payload.pays || "",
    budget: payload.budget || "",
    updatedAt: now()
  };

  if(p.session !== host.session) return;
  if(p.roomId !== currentRoomId()) return;

  if(host.mode==="city" && expectedVenue && !isVenueAllowed(expectedVenue)){
    showToast("Blocked", `Guest selected a non-participating venue: ${barName(expectedVenue)}.`);
    return;
  }

  upsertGuestById(stableId, p);
  ensureLikes(stableId);
  saveJSON(STORAGE.LIKES, likes);

  renderAll();
}

/* =========================
   CHECK-IN / MOVE / KICK
========================= */
function pickVenueByName(title){
  if(!bars.length) return null;
  const lines = bars.map((b,i)=>`${i+1}) ${b.name}`).join("\n");
  const pick = prompt(`${title}\n\nChoose a number:\n${lines}`, "1");
  const idx = Math.max(1, parseInt(pick||"1",10)) - 1;
  const chosen = bars[idx];
  return chosen ? chosen.id : null;
}

function hostSetStatus(id, status, venueOverrideId=null){
  if(!requireUnlock()) return;

  const p = people.find(x=>x.id===id);
  if(!p) return;

  if(status === "checked_in"){
    p.status = "checked_in";
    const v = (venueOverrideId || host.activeBarId || p.expectedVenueId || p.venueId || "").trim();
    if(host.mode==="city" && v && !isVenueAllowed(v)){
      showToast("Blocked", `Cannot check in to non-participating venue: ${barName(v)}`);
      return;
    }
    p.checkedInVenueId = v;
  }else if(status === "pending"){
    p.status = "pending";
    p.checkedInVenueId = "";
  }else if(status === "removed"){
    p.status = "removed";
  }
  p.updatedAt = now();
  saveJSON(STORAGE.PEOPLE, people);

  if(status === "checked_in"){
    activateTvForGuest(id);
  }

  renderAll();
  broadcastRosterSync(p.clientNonce || p.id);
  broadcastTVSync();
}

function hostMoveVenue(id, newVenueId){
  if(!requireUnlock()) return;

  const p = people.find(x=>x.id===id);
  if(!p) return;
  const v = String(newVenueId||"").trim();
  if(host.mode==="city" && v && !isVenueAllowed(v)){
    showToast("Blocked", `Cannot move to non-participating venue: ${barName(v)}`);
    return;
  }

  p.expectedVenueId = v;
  if(p.status === "checked_in") p.checkedInVenueId = v;
  p.updatedAt = now();
  saveJSON(STORAGE.PEOPLE, people);

  renderAll();
  broadcastRosterSync(p.clientNonce || p.id);
  broadcastTVSync();
}

function activateTvForGuest(id){
  const pool = activePool();
  const me = pool.find(x=>x.id===id);
  if(!me) return;
  for(const other of pool){
    if(other.id===id) continue;
    if(!isMutual(id, other.id)) continue;
    tryCreateTvMatchForPair(id, other.id);
  }
}

/* =========================
   PHONE CHECK-IN
========================= */
function findGuestsByPhone(phone10){
  const d = digitsOnly(phone10);
  if(d.length !== 10) return [];
  return activePool().filter(p => (p.status||"pending")==="pending" && digitsOnly(p.identityPhone) === d);
}
function phoneCheckIn(){
  if(!requireUnlock()) return;

  const raw = ($("checkinPhone")?.value || "").trim();
  const d = digitsOnly(raw);
  if(d.length !== 10) return showToast("Phone needed", "Enter a 10-digit phone number.");

  const venueId = ($("checkinVenue")?.value || host.activeBarId || "").trim();
  if(!venueId) return showToast("Venue needed", "Select a venue for check-in.");

  if(host.mode==="city" && !isVenueAllowed(venueId)){
    return showToast("Blocked", `Venue not participating: ${barName(venueId)}`);
  }

  const matches = findGuestsByPhone(d);
  if(matches.length === 0){
    const any = activePool().filter(p => digitsOnly(p.identityPhone)===d);
    if(any.length){
      return showToast("Already found", `That phone belongs to ${any[0].alias} (status: ${any[0].status || "pending"}).`);
    }
    return showToast("Not found", "No pending guest with that phone in this room/session.");
  }

  if(matches.length === 1){
    hostSetStatus(matches[0].id, "checked_in", venueId);
    $("checkinPhone").value = "";
    showToast("Checked in", `${matches[0].alias} checked in at ${barName(venueId)}.`);
    return;
  }

  const opts = matches.map((p,i)=>`${i+1}) ${p.alias} (Expected: ${barName(p.expectedVenueId || p.venueId || "")})`).join("\n");
  const pick = prompt("Multiple pending guests share this phone.\nChoose number:\n\n"+opts, "1");
  const idx = Math.max(1, parseInt(pick||"1",10)) - 1;
  const chosen = matches[idx];
  if(!chosen) return;

  hostSetStatus(chosen.id, "checked_in", venueId);
  $("checkinPhone").value = "";
  showToast("Checked in", `${chosen.alias} checked in at ${barName(venueId)}.`);
}

/* =========================
   TV MATCH RULE
========================= */
function idFromVoterNonce(voterNonce){
  if(!voterNonce) return null;
  const pool = activePool();
  const me = pool.find(p => p.clientNonce === voterNonce || p.id === voterNonce);
  return me?.id || null;
}
function tvHasPair(aId,bId){
  const key = pairKey(aId,bId);
  return (tv.matches||[]).some(m => pairKey(m.aId,m.bId) === key && m.expiresAt > now());
}
function activeTvMatches(){ return (tv.matches||[]).filter(m => m.expiresAt > now()); }

function tryCreateTvMatchForPair(aId,bId){
  const pool = activePool();
  const A = pool.find(x=>x.id===aId);
  const B = pool.find(x=>x.id===bId);
  if(!A || !B) return false;

  if(A.status !== "checked_in" || B.status !== "checked_in") return false;

  const plan = travelPlan(A,B);
  if(!plan.allowed) return false;

  const sc = scorePair(A,B);
  if(sc < MIN_MATCH_SCORE) return false;

  if(tvHasPair(aId,bId)) return false;

  tv.matches = activeTvMatches();
  tv.matches.push({
    aId, bId,
    score: sc,
    plan: plan.plan,
    code: makeMatchCode(),
    createdAt: now(),
    expiresAt: now() + TV_EXPIRE_MS
  });
  tv.matches.sort((x,y)=> y.score - x.score);
  saveJSON(STORAGE.TV, tv);

  renderAll();
  broadcastTVSync();
  return true;
}

/* =========================
   VOTES
========================= */
function handleVoteMessage(msg){
  const roomId = currentRoomId();
  const msgRoom = (msg.roomId || msg.room || msg.barId || "").trim();
  if(msg.session && msg.session !== host.session) return;
  if(msgRoom && msgRoom !== roomId) return;

  const voterNonce = (msg.voterNonce || msg.clientNonce || "").trim();
  const voterId = idFromVoterNonce(voterNonce);
  const targetId = (msg.targetId || "").trim();
  const likeVal = !!msg.like;

  if(!voterId || !targetId || voterId===targetId) return;

  const pool = activePool();
  if(!pool.some(p=>p.id===targetId)) return;

  ensureLikes(voterId);
  likes[voterId][targetId] = likeVal;
  saveJSON(STORAGE.LIKES, likes);

  if(isMutual(voterId, targetId)){
    tryCreateTvMatchForPair(voterId, targetId);
  }

  renderAll();
  broadcastRosterSync(voterNonce || null);
  broadcastTVSync();
}

/* =========================
   CONTACT SAVE
   Supports: phone, instagram, tiktok, facebook (optional fields)
========================= */
function handleContactSave(msg){
  const roomId = currentRoomId();
  const msgRoom = (msg.roomId || msg.room || msg.barId || "").trim();
  if(msg.session && msg.session !== host.session) return;
  if(msgRoom && msgRoom !== roomId) return;

  const voterNonce = (msg.voterNonce || msg.clientNonce || "").trim();
  const voterId = idFromVoterNonce(voterNonce);
  if(!voterId) return;

  const contact = (msg.contact && typeof msg.contact === "object") ? msg.contact : {};
  const phone = digitsOnly(contact.phone || "");
  const instagram = String(contact.instagram || "").trim();
  const tiktok = String(contact.tiktok || "").trim();
  const facebook = String(contact.facebook || "").trim();

  if(!contacts[voterId]) contacts[voterId] = {};
  if(phone.length===10) contacts[voterId].phone = phone;
  if(instagram) contacts[voterId].instagram = instagram;
  if(tiktok) contacts[voterId].tiktok = tiktok;
  if(facebook) contacts[voterId].facebook = facebook;
  saveJSON(STORAGE.CONTACTS, contacts);

  const p = people.find(x=>x.id===voterId);
  if(p && !digitsOnly(p.identityPhone) && phone.length===10){
    p.identityPhone = phone;
    p.updatedAt = now();
    saveJSON(STORAGE.PEOPLE, people);
  }

  safeSend({ type:"contact_saved_ack", roomId, room:roomId, barId:roomId, session:host.session, voterNonce, ok:true });
  showToast("Contact saved", `Saved for ${p?.alias || "guest"}.`);
  renderAll();
}

/* =========================
   COUNTS + HOTSPOT
========================= */
function computeCountsAndHotspot(){
  const pool = activePool();
  const expected = pool.filter(p => (p.status||"pending")==="pending" && (p.expectedVenueId || p.venueId));
  const checked = pool.filter(p => (p.status||"pending")==="checked_in");

  const active = activeTvMatches();
  const counts = new Map();
  for(const m of active){
    const A = pool.find(x=>x.id===m.aId);
    const B = pool.find(x=>x.id===m.bId);
    const aV = (A?.checkedInVenueId || A?.expectedVenueId || "").trim();
    const bV = (B?.checkedInVenueId || B?.expectedVenueId || "").trim();
    if(aV) counts.set(aV, (counts.get(aV)||0)+1);
    if(bV) counts.set(bV, (counts.get(bV)||0)+1);
  }
  let bestId="", bestCount=0;
  for(const [id,c] of counts.entries()){
    if(c>bestCount){ bestId=id; bestCount=c; }
  }
  const hotspotLabel = bestId ? `${barName(bestId)} (${bestCount})` : "—";

  return {
    expected: expected.length,
    checkedIn: checked.length,
    activeMatches: active.length,
    hotspotLabel
  };
}

/* =========================
   TV SYNC (includes flags + counts)
========================= */
function broadcastTVSync(){
  const roomId = currentRoomId();
  const pool = activePool();

  const active = activeTvMatches()
    .sort((a,b) => b.score - a.score)
    .map(m => {
      const A = pool.find(x => x.id === m.aId);
      const B = pool.find(x => x.id === m.bId);
      const aVenue = A?.checkedInVenueId || A?.expectedVenueId || "";
      const bVenue = B?.checkedInVenueId || B?.expectedVenueId || "";
      return {
        ...m,
        aAlias: A?.alias || "Guest",
        bAlias: B?.alias || "Guest",
        aVenueId: aVenue,
        bVenueId: bVenue,
        aCheckedIn: (A?.status === "checked_in"),
        bCheckedIn: (B?.status === "checked_in"),
        aStatus: A?.status || "pending",
        bStatus: B?.status || "pending"
      };
    });

  const counts = computeCountsAndHotspot();

  safeSend({
    type: "tv_sync",
    roomId, room: roomId, barId: roomId,
    session: host.session,
    matches: active,
    counts
  });
}

/* =========================
   WS CONNECT
========================= */
function wsConnect(isReconnect=false){
  if(WS && (WS.readyState===WebSocket.OPEN || WS.readyState===WebSocket.CONNECTING)) return;

  WS = new WebSocket(WS_URL);
  wsSetStatus("CONNECTING");

  WS.onopen = ()=>{
    wsSetStatus("CONNECTED");
    reconnectAttempts = 0;

    const roomId = currentRoomId();
    $("roomPill").textContent = roomId || "—";
    safeSend({ type:"join", role:"host", roomId, room: roomId, barId: roomId, session: host.session });

    startHeartbeat();
    broadcastConfig();
    broadcastTVSync();
    broadcastRosterSync(null);

    if(isReconnect) showToast("Reconnected", "WebSocket connection restored.");
  };

  WS.onmessage = (ev)=>{
    lastTrafficAt = now();
    let msg; try{ msg = JSON.parse(ev.data); }catch{ return; }

    if(msg.type==="pong" || msg.type==="heartbeat" || msg.type==="pong_ack"){ lastPongAt = now(); return; }
    if(msg.type==="ping"){
      lastPongAt = now();
      const roomId = currentRoomId();
      safeSend({ type:"pong", roomId, room: roomId, barId: roomId, session: host.session, t: now() });
      return;
    }

    if(msg.type === "request_config"){ broadcastConfig(); return; }
    if(msg.type === "request_tv_sync"){ broadcastTVSync(); return; }
    if(msg.type === "request_roster"){
      const requesterNonce = (msg.voterNonce || msg.clientNonce || "").trim() || null;
      broadcastRosterSync(requesterNonce);
      return;
    }
    if(msg.type === "vote"){ handleVoteMessage(msg); return; }
    if(msg.type === "contact_save"){ handleContactSave(msg); return; }

    if(msg.type === "submit_payload" || msg.type === "payload_received"){
      const payload = normalizeIncomingPayload(msg);
      if(!payload) return;
      if(!payloadRoomSessionOk(payload)) return;

      const fp = payloadFingerprint(payload);
      if(dedupeSeen(fp)){
        ackSubmit(payload.clientNonce || null);
        return;
      }

      importGuest(payload);
      ackSubmit(payload.clientNonce || null);

      showToast("Guest", "New guest received (Pending).");
      broadcastConfig();
      broadcastRosterSync(payload.clientNonce || null);
      broadcastTVSync();
      return;
    }
  };

  WS.onerror = ()=>{ wsSetStatus("ERROR"); };
  WS.onclose = ()=>{
    wsSetStatus("DISCONNECTED");
    stopHeartbeat();
    scheduleReconnect();
  };
}

/* =========================
   RENDERING
========================= */
function renderBars(){
  const sel = $("barSelect");
  sel.innerHTML = "";
  for(const b of bars){
    const opt=document.createElement("option");
    opt.value=b.id; opt.textContent=b.name;
    if(b.id===host.activeBarId) opt.selected=true;
    sel.appendChild(opt);
  }
  populateCheckinVenueSelect();
}
function renderEventBars(){
  const wrap = $("eventBars");
  wrap.innerHTML = "";
  const ids = event.participatingBarIds || [];
  if(!ids.length){
    wrap.innerHTML = `<div class="muted">No participating locations selected yet.</div>`;
    return;
  }
  for(const id of ids){
    const row=document.createElement("div");
    row.className="item";
    row.innerHTML = `
      <div style="min-width:0">
        <strong>${esc(barName(id))}</strong>
        <div class="sub mono">${esc(id)}</div>
      </div>
      <button class="btn small bad" data-remove="${esc(id)}" type="button">Remove</button>
    `;
    wrap.appendChild(row);
  }
  wrap.querySelectorAll("button[data-remove]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      if(!requireUnlock()) return;
      const id=btn.getAttribute("data-remove");
      event.participatingBarIds = (event.participatingBarIds||[]).filter(x=>x!==id);
      saveJSON(STORAGE.EVENT, event);
      renderEventBars();
      broadcastConfig();
      updateLinks();
    });
  });
}

function renderArrivals(){
  const wrap=$("arrivals");
  wrap.innerHTML="";
  const pool=activePool()
    .filter(p => (p.status||"pending")==="pending")
    .filter(p => matchSearch(p.alias));

  if(!pool.length){
    wrap.innerHTML=`<div class="muted">${(ui.search||"").trim() ? "No pending arrivals match your search." : "No pending arrivals."}</div>`;
    return;
  }

  pool.sort((a,b)=>String(a.alias||"").localeCompare(String(b.alias||""), undefined, {sensitivity:"base"}));

  for(const p of pool){
    const expected = p.expectedVenueId || p.venueId || "";
    const last4 = phoneLast4(p.identityPhone);
    const invalid = (host.mode==="city" && expected && !isVenueAllowed(expected));
    const el=document.createElement("div");
    el.className="item";
    el.innerHTML = `
      <div style="min-width:0">
        <strong>${esc(p.alias)} ${invalid ? `<span class="badge bad" style="margin-left:8px">INVALID VENUE</span>` : ``}</strong>
        <div class="sub">
          Expected: <span class="mono">${esc(barName(expected))}</span> • Travel: <span class="mono">${p.travelYes?"Yes":"No"}</span><br/>
          Phone: <span class="mono">${last4 ? ("••••"+esc(last4)) : "—"}</span> • ID: <span class="mono">${esc(p.id)}</span>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn small good" data-act="checkin" data-id="${esc(p.id)}" type="button">Check In</button>
        <button class="btn small warn" data-act="move" data-id="${esc(p.id)}" type="button">Move</button>
        <button class="btn small bad"  data-act="kick" data-id="${esc(p.id)}" type="button">Kick</button>
      </div>
    `;
    wrap.appendChild(el);
  }

  wrap.querySelectorAll("button[data-act]").forEach(btn=>{
    const id = btn.getAttribute("data-id");
    const act = btn.getAttribute("data-act");

    btn.addEventListener("click", ()=>{
      if(act==="checkin"){
        const venueId = ($("checkinVenue")?.value || host.activeBarId || "").trim();
        if(!venueId) return showToast("Venue needed","Pick a venue in the Check-In dropdown.");
        return hostSetStatus(id, "checked_in", venueId);
      }
      if(act==="kick") return hostSetStatus(id, "removed");
      if(act==="move"){
        if(!requireUnlock()) return;
        const chosen = pickVenueByName("Move expected venue to:");
        if(!chosen) return;
        hostMoveVenue(id, chosen);
      }
    });
  });
}

function renderCheckedIn(){
  const wrap=$("checkedIn");
  wrap.innerHTML="";
  const pool=activePool()
    .filter(p => (p.status||"pending")==="checked_in")
    .filter(p => matchSearch(p.alias));

  if(!pool.length){
    wrap.innerHTML=`<div class="muted">${(ui.search||"").trim() ? "No checked-in guests match your search." : "No one checked in yet."}</div>`;
    return;
  }

  pool.sort((a,b)=>String(a.alias||"").localeCompare(String(b.alias||""), undefined, {sensitivity:"base"}));

  for(const p of pool){
    const v = p.checkedInVenueId || p.expectedVenueId || "";
    const last4 = phoneLast4(p.identityPhone);
    const el=document.createElement("div");
    el.className="item";
    el.innerHTML = `
      <div style="min-width:0">
        <strong>${esc(p.alias)}</strong>
        <div class="sub">
          Checked In: <span class="mono">${esc(barName(v))}</span> • Travel: <span class="mono">${p.travelYes?"Yes":"No"}</span><br/>
          Phone: <span class="mono">${last4 ? ("••••"+esc(last4)) : "—"}</span> • ID: <span class="mono">${esc(p.id)}</span>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn small warn" data-act="move" data-id="${esc(p.id)}" type="button">Move</button>
        <button class="btn small bad"  data-act="kick" data-id="${esc(p.id)}" type="button">Kick</button>
      </div>
    `;
    wrap.appendChild(el);
  }

  wrap.querySelectorAll("button[data-act]").forEach(btn=>{
    const id = btn.getAttribute("data-id");
    const act = btn.getAttribute("data-act");
    btn.addEventListener("click", ()=>{
      if(act==="kick") return hostSetStatus(id, "removed");
      if(act==="move"){
        if(!requireUnlock()) return;
        const chosen = pickVenueByName("Move checked-in guest to:");
        if(!chosen) return;
        hostMoveVenue(id, chosen);
      }
    });
  });
}

function renderVenueCounts(){
  const wrap=$("venueCounts");
  wrap.innerHTML="";

  const pool = activePool();
  const expected = pool.filter(p => (p.status||"pending")==="pending" && (p.expectedVenueId || p.venueId));
  const checked = pool.filter(p => (p.status||"pending")==="checked_in");
  const active = activeTvMatches();

  const byVenue = new Map();
  for(const b of bars){
    byVenue.set(b.id, { id:b.id, name:b.name, expected:0, checkedIn:0, activeMatches:0 });
  }

  for(const p of expected){
    const v = p.expectedVenueId || p.venueId;
    if(byVenue.has(v)) byVenue.get(v).expected++;
  }
  for(const p of checked){
    const v = p.checkedInVenueId || p.expectedVenueId || p.venueId;
    if(byVenue.has(v)) byVenue.get(v).checkedIn++;
  }
  for(const m of active){
    const A = pool.find(x=>x.id===m.aId);
    const B = pool.find(x=>x.id===m.bId);
    const aV = A?.checkedInVenueId || A?.expectedVenueId || "";
    const bV = B?.checkedInVenueId || B?.expectedVenueId || "";
    if(byVenue.has(aV)) byVenue.get(aV).activeMatches++;
    if(byVenue.has(bV)) byVenue.get(bV).activeMatches++;
  }

  const list = Array.from(byVenue.values())
    .filter(x => x.id)
    .sort((a,b)=> (b.activeMatches - a.activeMatches) || (b.checkedIn - a.checkedIn) || (b.expected - a.expected) || a.name.localeCompare(b.name));

  const hotspot = list.length ? list[0] : null;
  $("hotspotPill").textContent = hotspot ? `${hotspot.name} (${hotspot.activeMatches})` : "—";

  if(!list.length){
    wrap.innerHTML = `<div class="muted">No venues yet.</div>`;
    return;
  }

  for(const v of list){
    const el=document.createElement("div");
    el.className="item";
    el.innerHTML = `
      <div style="min-width:0">
        <strong>${esc(v.name)}</strong>
        <div class="sub">
          Expected: <span class="mono">${v.expected}</span> • Checked In: <span class="mono">${v.checkedIn}</span><br/>
          Active Matches: <span class="mono">${v.activeMatches}</span>
        </div>
      </div>
      <div class="badge ${v.activeMatches>0 ? "good":"warn"}">${v.activeMatches>0 ? "HOT" : "IDLE"}</div>
    `;
    wrap.appendChild(el);
  }
}

function renderTVQueue(){
  const wrap=$("tvQueue");
  wrap.innerHTML="";
  tv.matches = activeTvMatches().sort((a,b)=>b.score-a.score);
  saveJSON(STORAGE.TV, tv);

  if(!tv.matches.length){
    wrap.innerHTML = `<div class="muted">No active TV matches yet.</div>`;
    return;
  }

  const pool=activePool();
  for(const m of tv.matches){
    const A = pool.find(x=>x.id===m.aId);
    const B = pool.find(x=>x.id===m.bId);
    const aAlias = A?.alias || "Guest A";
    const bAlias = B?.alias || "Guest B";

    const minsLeft = Math.max(0, Math.round((m.expiresAt-now())/60000));
    const el=document.createElement("div");
    el.className="item";
    el.innerHTML=`
      <div style="min-width:0">
        <strong>${esc(aAlias)} + ${esc(bAlias)} — ${Math.round(m.score*100)}%</strong>
        <div class="sub">
          Code: <span class="mono">${esc(m.code)}</span> • Expires: <span class="mono">${minsLeft}m</span><br/>
          ${esc(m.plan)}
        </div>
      </div>
      <div class="badge good">TV</div>
    `;
    wrap.appendChild(el);
  }
}

function renderCounts(){
  const pool = activePool();
  const expected = pool.filter(p => (p.status||"pending")==="pending" && (p.expectedVenueId || p.venueId));
  const checked = pool.filter(p => (p.status||"pending")==="checked_in");
  $("countExpected").textContent = expected.length;
  $("countCheckedIn").textContent = checked.length;
  $("countTV").textContent = activeTvMatches().length;
  $("countJoined").textContent = pool.length;
}

function updateLinks(){
  const base = new URL(location.href);
  const roomId = currentRoomId();

  const join = new URL(base);
  join.pathname = "/join.html";
  join.searchParams.set("room", roomId);
  join.searchParams.set("session", host.session);
  join.searchParams.set("mode", host.mode);
  join.searchParams.set("bars", JSON.stringify(bars.map(b=>({id:b.id,name:b.name}))));
  join.searchParams.set("participating", JSON.stringify(event.participatingBarIds || []));

  const tvu = new URL(base);
  tvu.pathname = "/tv.html";
  tvu.searchParams.set("room", roomId);
  tvu.searchParams.set("session", host.session);
  if(host.mode === "single") tvu.searchParams.set("venue", host.activeBarId);
  else tvu.searchParams.delete("venue");

  $("joinLink").textContent = join.toString();
  $("tvLink").textContent = tvu.toString();

  $("sessionPill").textContent = host.session;
  $("roomPill").textContent = roomId;
  $("minMatchPill").textContent = `${Math.round(MIN_MATCH_SCORE*100)}%`;
}

function renderAll(){
  $("wsUrlTxt").textContent = WS_URL;
  renderBars();
  $("modeSelect").value = host.mode;
  $("sessionCode").value = host.session;
  $("eventName").value = event.name || "";
  renderEventBars();

  renderArrivals();
  renderCheckedIn();
  renderVenueCounts();
  renderTVQueue();
  renderCounts();
  updateLinks();

  setSearch(ui.search);
  wsSetStatus(WS_STATE);
  setPinPill();
}

/* =========================
   ACTIONS
========================= */
function addBar(name){
  if(!requireUnlock()) return;
  const id=uid();
  bars.push({id,name});
  saveJSON(STORAGE.BARS,bars);
  host.activeBarId=id;
  saveJSON(STORAGE.HOST,host);
  renderAll();
  broadcastConfig();
}
function deleteBar(){
  if(!requireUnlock()) return;
  if(bars.length===1){ showToast("Blocked","Keep at least one bar."); return; }
  const id=host.activeBarId;
  bars=bars.filter(b=>b.id!==id);
  saveJSON(STORAGE.BARS,bars);
  host.activeBarId=bars[0].id;
  saveJSON(STORAGE.HOST,host);

  event.participatingBarIds = (event.participatingBarIds||[]).filter(x=>x!==id);
  saveJSON(STORAGE.EVENT,event);

  renderAll();
  broadcastConfig();
}
function clearRoster(){
  if(!requireUnlock()) return;

  const roomId=currentRoomId();
  const toRemove = people.filter(p => p.roomId===roomId && p.session===host.session).map(p=>p.id);
  const removeSet = new Set(toRemove);

  people = people.filter(p => !(p.roomId===roomId && p.session===host.session));
  saveJSON(STORAGE.PEOPLE, people);

  for(const id of removeSet){
    delete likes[id];
    delete contacts[id];
  }
  for(const voterId in likes){
    for(const targetId in (likes[voterId]||{})){
      if(removeSet.has(targetId)) delete likes[voterId][targetId];
    }
  }
  saveJSON(STORAGE.LIKES, likes);
  saveJSON(STORAGE.CONTACTS, contacts);

  tv.matches = tv.matches.filter(m => !(removeSet.has(m.aId) || removeSet.has(m.bId)));
  saveJSON(STORAGE.TV, tv);

  dedupe = {};
  saveJSON(STORAGE.DEDUPE, dedupe);

  renderAll();
  broadcastRosterSync(null);
  broadcastTVSync();
  showToast("Cleared","Roster + likes + contacts + TV queue cleared for this room/session.");
}
function createOrUpdateEvent(){
  if(!requireUnlock()) return;
  if(!event.eventId) event.eventId = "CITY-"+uid().slice(0,6).toUpperCase();
  event.name = $("eventName").value.trim() || event.name || "City Event";
  saveJSON(STORAGE.EVENT,event);
  renderAll();
  broadcastConfig();
  showToast("Event saved", "City event updated.");
}
function toggleParticipating(barId){
  if(!requireUnlock()) return;
  const list = new Set(event.participatingBarIds || []);
  if(list.has(barId)) list.delete(barId); else list.add(barId);
  event.participatingBarIds = Array.from(list);
  saveJSON(STORAGE.EVENT,event);
  renderEventBars();
  broadcastConfig();
  updateLinks();
}

function exportCSV(){
  const pool=activePool();
  const headers=["alias","id","status","identityPhone","expectedVenue","checkedInVenue","travelYes","foods","activities","firstDateLoc","firstDateAvail","pays","budget","publicBlurb","starter","instagram","tiktok","facebook"];
  let csv=headers.join(",")+"\n";
  for(const p of pool){
    const c = contacts[p.id] || {};
    const row=[
      p.alias,
      p.id,
      p.status || "pending",
      (p.identityPhone ? digitsOnly(p.identityPhone) : ""),
      barName(p.expectedVenueId || p.venueId),
      barName(p.checkedInVenueId || ""),
      p.travelYes?"Yes":"No",
      (p.foodChips||[]).join("|"),
      (p.activityChips||[]).join("|"),
      p.firstDateLoc||"",
      p.firstDateAvail||"",
      p.pays||"",
      p.budget||"",
      p.publicBlurb||"",
      p.starter||"",
      c.instagram||"",
      c.tiktok||"",
      c.facebook||""
    ].map(v=>{
      const s=String(v??"");
      return /[,"\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    });
    csv += row.join(",")+"\n";
  }

  const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download=`barfly_host_export_${host.session}.csv`;
  document.body.appendChild(a); a.click();
  setTimeout(()=>{URL.revokeObjectURL(a.href); a.remove();},0);
  showToast("Exported","CSV downloaded.");
}

async function copyText(txt){
  try{ await navigator.clipboard.writeText(txt); showToast("Copied","Link copied."); }
  catch{
    const ta=document.createElement("textarea");
    ta.value=txt; ta.style.position="fixed"; ta.style.left="-9999px";
    document.body.appendChild(ta);
    ta.select(); document.execCommand("copy");
    ta.remove();
    showToast("Copied","Link copied.");
  }
}

function stopIntervals(){
  if(timers.tvPurge){ clearInterval(timers.tvPurge); timers.tvPurge=null; }
  if(timers.rebroadcastConfig){ clearInterval(timers.rebroadcastConfig); timers.rebroadcastConfig=null; }
  if(timers.rosterSync){ clearInterval(timers.rosterSync); timers.rosterSync=null; }
}
function startIntervals(){
  stopIntervals();

  timers.tvPurge = setInterval(()=>{
    const before=(tv.matches||[]).length;
    tv.matches=(tv.matches||[]).filter(m=>m.expiresAt>now()).sort((a,b)=>b.score-a.score);
    if((tv.matches||[]).length!==before){
      saveJSON(STORAGE.TV,tv);
      renderAll();
      broadcastTVSync();
    }
  }, 30*1000);

  timers.rebroadcastConfig = setInterval(()=>broadcastConfig(), 60*1000);
  timers.rosterSync = setInterval(()=>{ if(WS_STATE==="CONNECTED") broadcastRosterSync(null); }, 25*1000);
}

/* =========================
   QR HELPERS
========================= */
function openQR(title, url){
  const back = $("qrBack");
  $("qrTitle").textContent = title;
  $("qrLinkTxt").textContent = url;

  // simple hosted QR image (works great on phones)
  const qr = $("qrImg");
  const api = "https://api.qrserver.com/v1/create-qr-code/?size=260x260&data=" + encodeURIComponent(url);
  qr.src = api;

  back.style.display = "flex";
}
function closeQR(){ $("qrBack").style.display = "none"; }
function wireQR(){
  $("btnCloseQR").addEventListener("click", closeQR);
  $("qrBack").addEventListener("click", (e)=>{ if(e.target.id==="qrBack") closeQR(); });
  window.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeQR(); });
}

/* =========================
   INIT
========================= */
function init(){
  ensureDefaultBar();
  saveJSON(STORAGE.BARS,bars);
  saveJSON(STORAGE.HOST,host);
  saveJSON(STORAGE.EVENT,event);

  $("btnHostPin").addEventListener("click", handlePinButton);
  setPinPill();

  $("searchAlias").value = ui.search || "";
  setSearch(ui.search);

  $("searchAlias").addEventListener("input", (e)=>{
    setSearch(e.target.value);
    renderAll();
  });
  $("searchAlias").addEventListener("keydown", (e)=>{
    if(e.key==="Escape"){
      e.preventDefault();
      $("searchAlias").value="";
      setSearch("");
      renderAll();
    }
  });
  $("btnClearSearch").addEventListener("click", ()=>{
    $("searchAlias").value="";
    setSearch("");
    renderAll();
  });

  $("btnPhoneCheckin").addEventListener("click", phoneCheckIn);
  $("checkinPhone").addEventListener("keydown", (e)=>{
    if(e.key==="Enter") phoneCheckIn();
  });

  renderAll();
  startIntervals();
  wsConnect();

  $("modeSelect").addEventListener("change", ()=>{
    if(!requireUnlock()) { $("modeSelect").value = host.mode; return; }
    host.mode = $("modeSelect").value;
    saveJSON(STORAGE.HOST,host);
    cleanupWs(); wsConnect();
    renderAll();
    broadcastConfig(); broadcastTVSync(); broadcastRosterSync(null);
  });

  $("sessionCode").addEventListener("change", ()=>{
    if(!requireUnlock()) { $("sessionCode").value = host.session; return; }
    host.session = $("sessionCode").value.trim() || host.session;
    saveJSON(STORAGE.HOST,host);
    cleanupWs(); wsConnect();
    renderAll();
    broadcastConfig(); broadcastTVSync(); broadcastRosterSync(null);
  });

  $("btnNewSession").addEventListener("click", ()=>{
    if(!requireUnlock()) return;
    host.session = genSession();
    saveJSON(STORAGE.HOST,host);
    tv.matches = [];
    saveJSON(STORAGE.TV,tv);
    dedupe = {};
    saveJSON(STORAGE.DEDUPE, dedupe);
    cleanupWs(); wsConnect();
    renderAll();
    showToast("New session","Session refreshed.");
  });

  $("barSelect").addEventListener("change", ()=>{
    if(!requireUnlock()) { $("barSelect").value = host.activeBarId; return; }
    host.activeBarId = $("barSelect").value;
    saveJSON(STORAGE.HOST,host);
    renderAll();
    broadcastConfig();
    broadcastTVSync();
    broadcastRosterSync(null);
  });

  $("btnAddBar").addEventListener("click", ()=>{
    const name=$("newBarName").value.trim();
    if(!name) return showToast("Missing","Enter bar name.");
    addBar(name);
    $("newBarName").value="";
  });

  $("btnDeleteBar").addEventListener("click", deleteBar);
  $("btnClearRoster").addEventListener("click", clearRoster);

  $("btnCreateEvent").addEventListener("click", createOrUpdateEvent);

  $("barSelect").addEventListener("dblclick", ()=>{
    if(host.mode!=="city") return;
    toggleParticipating(host.activeBarId);
    showToast("Participation", "Toggled participating for selected bar.");
  });

  $("btnRefresh").addEventListener("click", ()=>{ renderAll(); showToast("Updated","Refreshed view."); });

  $("btnComputeMutuals").addEventListener("click", ()=>{
    if(!requireUnlock()) return;

    const pool = activePool();
    const ids = pool.map(p=>p.id);
    tv.matches = activeTvMatches();
    const seen = new Set(tv.matches.map(m => pairKey(m.aId,m.bId)));

    for(let i=0;i<ids.length;i++){
      for(let j=i+1;j<ids.length;j++){
        const aId=ids[i], bId=ids[j];
        if(!isMutual(aId,bId)) continue;

        const A = pool.find(x=>x.id===aId);
        const B = pool.find(x=>x.id===bId);
        if(!A || !B) continue;
        if(A.status!=="checked_in" || B.status!=="checked_in") continue;

        const plan = travelPlan(A,B);
        if(!plan.allowed) continue;

        const sc = scorePair(A,B);
        if(sc < MIN_MATCH_SCORE) continue;

        const key = pairKey(aId,bId);
        if(!seen.has(key)){
          tv.matches.push({
            aId,bId,
            score: sc,
            plan: plan.plan,
            code: makeMatchCode(),
            createdAt: now(),
            expiresAt: now() + TV_EXPIRE_MS
          });
          seen.add(key);
        }
      }
    }

    tv.matches.sort((x,y)=> y.score - x.score);
    saveJSON(STORAGE.TV, tv);

    renderAll();
    broadcastTVSync();
    showToast("Computed", `TV queue updated (${activeTvMatches().length} active).`);
  });

  $("btnBroadcastConfig").addEventListener("click", ()=>{
    if(!requireUnlock()) return;
    broadcastConfig();
    broadcastRosterSync(null);
    broadcastTVSync();
    showToast("Broadcast","Config + roster + TV sent to room.");
  });

  $("btnExport").addEventListener("click", exportCSV);

  const copyJoin = ()=>{ updateLinks(); copyText($("joinLink").textContent); };
  const copyTV   = ()=>{ updateLinks(); copyText($("tvLink").textContent); };

  $("btnCopyJoin").addEventListener("click", copyJoin);
  $("btnCopyJoin2").addEventListener("click", copyJoin);
  $("btnCopyTV").addEventListener("click", copyTV);
  $("btnCopyTV2").addEventListener("click", copyTV);

  // QR buttons
  $("btnShowJoinQR").addEventListener("click", ()=>{
    updateLinks();
    openQR("Join QR", $("joinLink").textContent);
  });
  $("btnShowTVQR").addEventListener("click", ()=>{
    updateLinks();
    openQR("TV QR", $("tvLink").textContent);
  });
  wireQR();

  window.addEventListener("beforeunload", ()=>{
    stopIntervals();
    cleanupWs();
  });
}
init();
</script>
</body>
</html>













