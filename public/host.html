<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Barfly Social ‚Äî Host Dashboard</title>
  <style>
    :root{
      --bg:#070a12; --txt:#e9f0ff; --muted:#a7b3d1; --line:rgba(255,255,255,.12);
      --good:#2dd4bf; --brand:#60a5fa; --warn:#fbbf24; --bad:#fb7185;
      --shadow:0 10px 30px rgba(0,0,0,.35); --r:18px;
      --net:#60a5fa; --date:#2dd4bf;
      --panel:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:
        radial-gradient(1400px 900px at 10% 0%, rgba(96,165,250,.18), transparent 60%),
        radial-gradient(1200px 800px at 100% 0%, rgba(45,212,191,.14), transparent 55%),
        var(--bg);
      color:var(--txt);
    }
    .wrap{max-width:1500px;margin:0 auto;padding:18px}
    .top{display:flex;justify-content:space-between;align-items:flex-start;gap:14px;flex-wrap:wrap;margin-bottom:14px}
    .title{font-weight:1000;font-size:30px;letter-spacing:.4px}
    .sub{color:var(--muted);font-weight:850;line-height:1.35}
    .pillRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      border:1px solid var(--line);
      padding:10px 12px;border-radius:999px;
      background:rgba(255,255,255,.03);
      font-size:14px;color:var(--muted);
      white-space:nowrap;max-width:min(620px, 94vw)
    }
    .pill b{color:var(--txt)}
    .pill.good{border-color:rgba(45,212,191,.35);background:rgba(45,212,191,.08)}
    .pill.warn{border-color:rgba(251,191,36,.35);background:rgba(251,191,36,.08)}
    .pill.bad{border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.08)}
    .pill.net{border-color:rgba(96,165,250,.38);background:rgba(96,165,250,.10);color:#bcd8ff}
    .pill.date{border-color:rgba(45,212,191,.40);background:rgba(45,212,191,.10);color:#c9fff2}
    .k{
      display:inline-flex;gap:8px;align-items:center;
      border:1px solid var(--line);
      padding:7px 10px;border-radius:999px;
      background:rgba(255,255,255,.03);
      color:var(--muted);font-weight:900;font-size:12px
    }

    .row{display:grid;grid-template-columns: 440px 1fr; gap:14px; align-items:start}
    @media(max-width:1100px){ .row{grid-template-columns:1fr} }

    .card{
      border:1px solid var(--line);
      border-radius:var(--r);
      background:var(--panel);
      box-shadow:var(--shadow);
      padding:14px;
    }
    .card h3{margin:0 0 10px;font-size:16px;font-weight:1000}
    .hr{height:1px;background:var(--line);margin:12px 0}
    label{display:block;font-size:13px;color:var(--muted);font-weight:900;margin-bottom:6px}
    input,select{
      width:100%;
      padding:12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
      font-size:16px
    }
    .btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--txt);
      padding:11px 12px;
      border-radius:14px;
      font-weight:950;
      cursor:pointer;
      display:inline-flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      user-select:none;
      width:100%;
    }
    .btn.primary{background:rgba(96,165,250,.20);border-color:rgba(96,165,250,.35)}
    .btn.good{background:rgba(45,212,191,.16);border-color:rgba(45,212,191,.35)}
    .btn.warn{background:rgba(251,191,36,.12);border-color:rgba(251,191,36,.35)}
    .btn.bad{background:rgba(251,113,133,.16);border-color:rgba(251,113,133,.35)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media(max-width:560px){ .two{grid-template-columns:1fr} }

    .seg{
      display:inline-flex;
      border:1px solid var(--line);
      border-radius:999px;
      overflow:hidden;
      background:rgba(255,255,255,.03);
      width:max-content;
      max-width:100%;
    }
    .seg button{
      border:0;
      background:transparent;
      color:var(--muted);
      padding:10px 12px;
      font-weight:950;
      cursor:pointer;
      white-space:nowrap;
    }
    .seg button.on{
      color:var(--txt);
      background:rgba(45,212,191,.12);
      outline:1px solid rgba(45,212,191,.20);
    }

    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:14px}
    @media(max-width:1400px){.grid{grid-template-columns:repeat(2,1fr)}}
    @media(max-width:720px){.grid{grid-template-columns:1fr}}

    .matchCard{min-height:140px}
    .pair{font-weight:1000;font-size:18px;line-height:1.2}
    .meta{margin-top:8px;color:var(--muted);font-weight:900;line-height:1.35}
    .code{
      display:inline-block;margin-top:10px;padding:8px 10px;border-radius:999px;
      border:1px solid rgba(45,212,191,.35);
      background:rgba(45,212,191,.10);
      color:var(--good);font-weight:1000
    }
    .code.net{border-color:rgba(96,165,250,.38);background:rgba(96,165,250,.10);color:#bcd8ff}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}

    .badge{
      display:inline-flex;align-items:center;gap:6px;
      padding:6px 9px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      font-size:12px;font-weight:950;color:var(--muted)
    }
    .badge.good{border-color:rgba(45,212,191,.35);background:rgba(45,212,191,.08);color:#c9fff2}
    .badge.bad{border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.08);color:#ffd2db}
    .badge.warn{border-color:rgba(251,191,36,.35);background:rgba(251,191,36,.08);color:#ffe6b0}

    .toast{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background:rgba(17,26,43,.92);
      border:1px solid var(--line);
      border-radius:18px;
      padding:12px 14px;
      box-shadow:var(--shadow);
      display:none;
      max-width:92vw;
      z-index:60
    }
    .toast .t{font-weight:1000;margin-bottom:2px}
    .toast .m{font-size:13px;color:var(--muted);font-weight:850;line-height:1.35}
    .small{font-size:12px;color:var(--muted);font-weight:850}
    .hidden{display:none !important;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div style="min-width:320px">
      <div class="title" id="titleText">Host Dashboard ‚Äî Matches</div>
      <div class="sub" id="subText">
        Toggle between <b>Host Venue</b> and <b>All Venues</b>. Shows <b>checked-in status</b> and <b>where</b>.
      </div>
      <div class="small" style="margin-top:8px">
        Link format: <span class="mono">?room=ROOMID&session=SESSIONID&venue=VENUEID</span>
      </div>
    </div>

    <div class="pillRow">
      <div class="pill" id="eventPillWrap"><b>Event</b> <span id="eventPill">‚Äî</span></div>
      <div class="pill"><b>Room</b> <span id="roomPill">‚Äî</span></div>
      <div class="pill"><b>Session</b> <span id="sessionPill">‚Äî</span></div>
      <div class="pill" id="venuePillWrap"><b>Host Venue</b> <span id="venuePill">‚Äî</span></div>
      <div class="pill" id="wsPillWrap"><b>WS</b> <span id="wsPill">DISCONNECTED</span></div>
      <div class="pill" id="syncPillWrap"><b>Last Sync</b> <span id="syncPill">‚Äî</span></div>
      <div class="pill warn"><b>Expected</b> <span id="expectedPill">0</span></div>
      <div class="pill good"><b>Checked In</b> <span id="checkedInPill">0</span></div>
      <div class="pill good"><b>Active</b> <span id="activeMatchesPill">0</span></div>
      <div class="pill"><b>Hotspot</b> <span id="hotspotPill">‚Äî</span></div>
    </div>
  </div>

  <div class="row">
    <!-- LEFT: Controls -->
    <div class="card">
      <h3>Controls</h3>

      <div class="two">
        <div>
          <label>Host Venue (used for ‚ÄúHost Venue‚Äù view)</label>
          <select id="hostVenueSelect">
            <option value="" selected>Waiting for config‚Ä¶</option>
          </select>
          <div class="small" style="margin-top:6px">
            This is the venue used when filter is set to <b>Host Venue</b>.
          </div>
        </div>
        <div>
          <label>View</label>
          <div class="seg">
            <button id="btnFilterHost" class="on" type="button">Host Venue</button>
            <button id="btnFilterAll" type="button">All Venues</button>
          </div>
          <div class="small" style="margin-top:10px">
            <span class="k">Shows venues + check-in status</span>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="two">
        <button class="btn primary" id="btnRequestConfig" type="button">Request Config</button>
        <button class="btn good" id="btnRequestSync" type="button">Request Matches</button>
      </div>

      <div class="two" style="margin-top:10px">
        <button class="btn warn" id="btnToggleAuto" type="button">Auto-Refresh: OFF</button>
        <button class="btn" id="btnClearLocal" type="button">Clear Local Cache</button>
      </div>

      <div class="hr"></div>

      <div class="two">
        <div>
          <label>Show only pairs where BOTH are checked in?</label>
          <select id="checkedOnly">
            <option value="yes" selected>Yes (TV-style)</option>
            <option value="no">No (show all matches)</option>
          </select>
        </div>
        <div>
          <label>Rotation</label>
          <select id="rotation">
            <option value="0">No rotation</option>
            <option value="10" selected>Rotate every 10s</option>
            <option value="5">Rotate every 5s</option>
            <option value="15">Rotate every 15s</option>
          </select>
        </div>
      </div>

      <div class="small" style="margin-top:10px">
        If matches aren‚Äôt appearing: make sure your compute/broadcast button on the host tool is sending
        <span class="mono">tv_sync</span> to the relay for this <b>room</b> + <b>session</b>.
      </div>
    </div>

    <!-- RIGHT: Matches -->
    <div class="card">
      <h3>Matches</h3>
      <div class="small" id="matchesNote">Waiting for sync‚Ä¶</div>
      <div class="hr"></div>
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <div class="toast" id="toast">
    <div class="t" id="toastT">Updated</div>
    <div class="m" id="toastM">‚Äî</div>
  </div>
</div>

<script>
/* ============================================================
   Barfly Social ‚Äî Host Dashboard (REPLACEMENT FILE)

   Adds:
   - Toggle: Host Venue vs All Venues
   - Shows checked-in status for each side + venue labels
   - Optional: show only checked-in pairs (TV-style)
   - Auto-refresh + optional rotation

   Relay expectations (same as your TV page):
   - request_config -> receives config/event_config
   - request_tv_sync -> receives tv_sync { matches: [...] }

============================================================ */

const WS_URL = "wss://bar-match-relay.onrender.com";

const HEARTBEAT_MS = 15 * 1000;
const STALE_MS     = 45 * 1000;

const PER_PAGE = 9;

const $ = (id)=>document.getElementById(id);

function qs(){
  const u=new URL(location.href);
  const q = Object.fromEntries(u.searchParams.entries());
  q.room    = (q.room || q.roomId || q.barId || "").trim();
  q.session = (q.session || "").trim();
  q.venue   = (q.venue || "").trim(); // optional host venue hint
  q.event   = (q.event || q.eventType || q.type || "").trim().toLowerCase();
  return q;
}
function esc(s){
  return String(s??"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}
function showToast(t,m){
  $("toastT").textContent=t;
  $("toastM").textContent=m;
  const el=$("toast");
  el.style.display="block";
  clearTimeout(showToast._t);
  showToast._t=setTimeout(()=>{el.style.display="none"}, 2600);
}

/* =========================
   Event type/name
========================= */
let EVENT_TYPE=""; // dating | networking | ""
let EVENT_NAME="";

function normalizeEventType(raw){
  const s = String(raw||"").trim().toLowerCase();
  if(!s) return "";
  if(s.includes("network")) return "networking";
  if(s.includes("dating")) return "dating";
  if(s === "net") return "networking";
  if(s === "date") return "dating";
  return "";
}
function inferEventTypeFromConfig(cfg){
  const candidates = [
    cfg?.eventType,
    cfg?.event,
    cfg?.type,
    cfg?.mode,
    cfg?.event?.type,
    cfg?.settings?.eventType,
    cfg?.settings?.type
  ];
  for(const c of candidates){
    const n = normalizeEventType(c);
    if(n) return n;
  }
  return "";
}
function inferEventNameFromConfig(cfg){
  return (cfg?.event?.name ?? cfg?.name ?? cfg?.eventName ?? "").toString().trim();
}
function buildEventLabel(){
  const t = EVENT_TYPE || "";
  const n = (EVENT_NAME || "").trim();
  if(t === "networking") return n ? `üíº Professional Networking ‚Äî ${n}` : `üíº Professional Networking`;
  if(t === "dating") return n ? `üíö Dating Night ‚Äî ${n}` : `üíö Dating Night`;
  return n ? `Live Event ‚Äî ${n}` : `Live Event`;
}
function applyEventUI(){
  const wrap = $("eventPillWrap");
  const pill = $("eventPill");
  let pillClass = "pill";
  if(EVENT_TYPE==="networking") pillClass = "pill net";
  if(EVENT_TYPE==="dating") pillClass = "pill date";
  wrap.className = pillClass;
  pill.textContent = buildEventLabel();

  const label = buildEventLabel();
  document.title = `Barfly Social ‚Äî Host ‚Ä¢ ${label}`;
  $("titleText").textContent = `Host Dashboard ‚Äî ${EVENT_TYPE==="networking" ? "Networking" : EVENT_TYPE==="dating" ? "Dating" : "Live"} Matches`;
}

/* =========================
   State
========================= */
let WS=null;
let WS_STATE="DISCONNECTED";
let HOST_CONFIG=null;

let lastTrafficAt = Date.now();
let lastSyncAt = 0;

let matches = [];
let page = 0;

let autoOn = false;
let autoTimer = null;
let rotateTimer = null;

let filterMode = "host"; // "host" | "all"
let hostVenueId = "";    // selected in dropdown

/* =========================
   Local storage
========================= */
const LS_KEY = "barfly_host_matches_prefs_v1";

function loadPrefs(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return;
    const p = JSON.parse(raw);
    if(p.filterMode) filterMode = p.filterMode;
    if(p.hostVenueId) hostVenueId = p.hostVenueId;
    if(p.checkedOnly) $("checkedOnly").value = p.checkedOnly;
    if(p.rotation != null) $("rotation").value = String(p.rotation);
    if(p.autoOn != null) autoOn = !!p.autoOn;
  }catch{}
}
function savePrefs(){
  try{
    const p = {
      filterMode,
      hostVenueId,
      checkedOnly: $("checkedOnly").value,
      rotation: Number($("rotation").value || 0),
      autoOn
    };
    localStorage.setItem(LS_KEY, JSON.stringify(p));
  }catch{}
}

/* =========================
   Pills / status
========================= */
function setWsStatus(s){
  WS_STATE=s;
  $("wsPill").textContent=s;
  $("wsPillWrap").className = "pill " + (s==="CONNECTED"?"good": s==="CONNECTING"?"warn": s==="ERROR"?"bad":"");
}
function setSyncPill(){
  const age = lastSyncAt ? Math.max(0, Math.round((Date.now()-lastSyncAt)/1000)) : null;
  $("syncPill").textContent = age==null ? "‚Äî" : `${age}s`;
  const cls = (age==null) ? "" : (age <= 10 ? " good" : age <= 25 ? " warn" : " bad");
  $("syncPillWrap").className = "pill" + cls;
}

/* =========================
   Config: venue labels
========================= */
function barNameFromCfg(id){
  const clean = String(id||"").trim();
  if(!clean) return "";
  const b = (HOST_CONFIG?.bars || []).find(x => x.id === clean);
  return (b?.name || clean);
}
function labelVenue(id){
  const clean = String(id||"").trim();
  if(!clean) return "‚Äî";
  return barNameFromCfg(clean) || clean;
}
function setHostVenuePill(){
  const wrap = $("venuePillWrap");
  const pill = $("venuePill");
  if(!hostVenueId){
    wrap.classList.add("hidden");
    pill.textContent = "‚Äî";
  }else{
    wrap.classList.remove("hidden");
    pill.textContent = labelVenue(hostVenueId);
  }
}

function populateVenueSelectFromConfig(){
  const sel = $("hostVenueSelect");
  const bars = Array.isArray(HOST_CONFIG?.bars) ? HOST_CONFIG.bars : [];

  sel.innerHTML = "";
  if(!bars.length){
    sel.innerHTML = `<option value="" selected>Waiting for config‚Ä¶</option>`;
    return;
  }

  sel.innerHTML = `<option value="" disabled>Select host venue</option>`;
  for(const b of bars){
    const opt = document.createElement("option");
    opt.value = b.id;
    opt.textContent = b.name || b.id;
    sel.appendChild(opt);
  }

  const urlVenue = String(qs().venue||"").trim();
  const preferred = hostVenueId || urlVenue || bars[0]?.id || "";
  if(preferred){
    sel.value = preferred;
    hostVenueId = preferred;
  }else{
    sel.value = bars[0]?.id || "";
    hostVenueId = sel.value;
  }
  setHostVenuePill();
  savePrefs();
}

/* =========================
   Relay helpers
========================= */
function touchTraffic(){ lastTrafficAt = Date.now(); }

function safeSend(obj){
  try{
    if(WS && WS.readyState===WebSocket.OPEN){
      WS.send(JSON.stringify(obj));
      return true;
    }
  }catch{}
  return false;
}
function requestConfig(){
  const q=qs();
  if(!q.room || !q.session) return;
  safeSend({ type:"request_config", roomId:q.room, room:q.room, barId:q.room, session:q.session });
}
function requestSync(){
  const q=qs();
  if(!q.room || !q.session) return;
  safeSend({ type:"request_tv_sync", roomId:q.room, room:q.room, barId:q.room, session:q.session });
}

/* =========================
   Check-in helpers
========================= */
function isCheckedInFlag(m, side){
  const isA = side==="a";
  const v1 = isA ? m.aCheckedIn : m.bCheckedIn;
  const v2 = isA ? m.checkedInA : m.checkedInB;
  const st = isA ? (m.aStatus || m.statusA) : (m.bStatus || m.statusB);

  if(typeof v1 === "boolean") return v1;
  if(typeof v2 === "boolean") return v2;
  if(typeof st === "string") return st.toLowerCase().includes("check");
  return undefined; // unknown
}

function badgeHTML(flag){
  if(flag === true)  return `<span class="badge good">‚úì Checked In</span>`;
  if(flag === false) return `<span class="badge bad">‚úó Not Checked</span>`;
  return `<span class="badge warn">‚Ä¢ Unknown</span>`;
}

/* =========================
   Filtering + counts
========================= */
function filteredMatches(){
  const checkedOnly = $("checkedOnly").value === "yes";
  const now = Date.now();

  let list = (matches || []).filter(m => !m.expiresAt || m.expiresAt > now);

  if(checkedOnly){
    list = list.filter(m => isCheckedInFlag(m,"a") === true && isCheckedInFlag(m,"b") === true);
  }

  if(filterMode === "host" && hostVenueId){
    list = list.filter(m => (String(m.aVenueId||"").trim() === hostVenueId) || (String(m.bVenueId||"").trim() === hostVenueId));
  }

  list.sort((a,b)=>(b.score||0)-(a.score||0));
  return list;
}

function computeHotspot(list){
  const counts = new Map();
  for(const m of list){
    const av = String(m.aVenueId||"").trim();
    const bv = String(m.bVenueId||"").trim();
    if(av) counts.set(av, (counts.get(av)||0)+1);
    if(bv) counts.set(bv, (counts.get(bv)||0)+1);
  }
  let bestId="", bestCount=0;
  for(const [id,c] of counts.entries()){
    if(c > bestCount){ bestId=id; bestCount=c; }
  }
  if(!bestId) return "‚Äî";
  return `${labelVenue(bestId)} (${bestCount})`;
}

function setCountsFromMsg(msg){
  const c = msg.counts || msg.stats || msg.summary || {};
  const expected =
    (typeof c.expected === "number" ? c.expected :
    typeof c.pendingExpected === "number" ? c.pendingExpected :
    typeof msg.expected === "number" ? msg.expected : null);

  const checkedIn =
    (typeof c.checkedIn === "number" ? c.checkedIn :
    typeof c.arrived === "number" ? c.arrived :
    typeof msg.checkedIn === "number" ? msg.checkedIn : null);

  if(expected!=null) $("expectedPill").textContent = String(expected);
  if(checkedIn!=null) $("checkedInPill").textContent = String(checkedIn);
}

function setCountsFallback(){
  // fallback: count distinct checked-in guests inside current dataset
  const checked = new Set();
  for(const m of matches || []){
    if(isCheckedInFlag(m,"a") === true) checked.add("a:"+String(m.aId||m.aAlias||m.a||""));
    if(isCheckedInFlag(m,"b") === true) checked.add("b:"+String(m.bId||m.bAlias||m.b||""));
  }
  $("checkedInPill").textContent = String(checked.size || 0);

  const active = filteredMatches();
  $("activeMatchesPill").textContent = String(active.length);
  $("hotspotPill").textContent = computeHotspot(active);
}

/* =========================
   Render
========================= */
function render(){
  setSyncPill();

  // update toggle UI
  $("btnFilterHost").classList.toggle("on", filterMode==="host");
  $("btnFilterAll").classList.toggle("on", filterMode==="all");

  // update host venue pill visibility
  setHostVenuePill();

  const list = filteredMatches();
  $("activeMatchesPill").textContent = String(list.length);
  $("hotspotPill").textContent = computeHotspot(list);

  const grid = $("grid");
  grid.innerHTML = "";

  const viewLabel = (filterMode==="host" ? "Host Venue" : "All Venues");
  const hv = (filterMode==="host" && hostVenueId) ? ` ‚Ä¢ ${labelVenue(hostVenueId)}` : "";
  $("matchesNote").textContent = `View: ${viewLabel}${hv} ‚Ä¢ Checked-only: ${$("checkedOnly").value==="yes" ? "Yes" : "No"} ‚Ä¢ Total shown: ${list.length}`;

  if(!list.length){
    grid.innerHTML = `
      <div class="card matchCard" style="grid-column:1/-1">
        <div class="pair">No matches to show (based on filters).</div>
        <div class="meta">
          Click <b>Request Matches</b>. If still blank, the relay may not be sending <span class="mono">tv_sync</span> for this session.
          <div style="margin-top:10px">
            <span class="k">Filter: <b>${esc(viewLabel)}</b></span>
            ${filterMode==="host" && hostVenueId ? `<span class="k">Host Venue: <b>${esc(labelVenue(hostVenueId))}</b></span>` : ``}
            <span class="k">Checked-only: <b>${$("checkedOnly").value==="yes" ? "Yes" : "No"}</b></span>
          </div>
        </div>
      </div>
    `;
    return;
  }

  const pages = Math.max(1, Math.ceil(list.length / PER_PAGE));
  page = page % pages;

  const labelCode = (EVENT_TYPE === "networking") ? "Connect Code" : "Match Code";
  const codeClass = (EVENT_TYPE === "networking") ? "code net" : "code";

  const slice = list.slice(page*PER_PAGE, page*PER_PAGE + PER_PAGE);

  for(const m of slice){
    const el = document.createElement("div");
    el.className = "card matchCard";

    const aIn = isCheckedInFlag(m,"a");
    const bIn = isCheckedInFlag(m,"b");

    const aAlias = m.aAlias || m.a || m.aliasA || "Guest A";
    const bAlias = m.bAlias || m.b || m.aliasB || "Guest B";

    const aVenue = String(m.aVenueId||"").trim();
    const bVenue = String(m.bVenueId||"").trim();

    const percent = Math.round((m.score||0)*100);

    const plan = (m.plan || "").trim() || (EVENT_TYPE==="networking"
      ? "See host to connect professionally."
      : "See host to connect.");

    const venuesLine = `
      <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
        <span class="badge">${esc(aAlias)} @ <span class="mono">${esc(labelVenue(aVenue))}</span></span>
        ${badgeHTML(aIn)}
        <span class="badge">${esc(bAlias)} @ <span class="mono">${esc(labelVenue(bVenue))}</span></span>
        ${badgeHTML(bIn)}
      </div>
    `;

    el.innerHTML = `
      <div class="pair">${esc(aAlias)} + ${esc(bAlias)} ‚Äî ${percent}%</div>
      <div class="meta">
        ${esc(plan)}
        ${venuesLine}
      </div>
      <div class="${codeClass}">${labelCode}: <span class="mono">${esc(m.code||"‚Äî")}</span></div>
    `;
    grid.appendChild(el);
  }
}

/* =========================
   Rotation + Auto-refresh
========================= */
function setRotation(){
  const sec = Number($("rotation").value || 0);
  clearInterval(rotateTimer);
  rotateTimer = null;

  if(sec > 0){
    rotateTimer = setInterval(()=>{
      page++;
      render();
    }, sec * 1000);
  }
  savePrefs();
}

function setAuto(){
  clearInterval(autoTimer);
  autoTimer = null;

  $("btnToggleAuto").textContent = `Auto-Refresh: ${autoOn ? "ON" : "OFF"}`;

  if(autoOn){
    autoTimer = setInterval(()=>{
      if(WS_STATE==="CONNECTED") requestSync();
    }, 25 * 1000);
  }
  savePrefs();
}

/* =========================
   Connect WS
========================= */
let hbTimer=null;

function heartbeatTick(){
  if(WS_STATE!=="CONNECTED") return;
  const q=qs();
  safeSend({ type:"ping", roomId:q.room, room:q.room, barId:q.room, session:q.session, t: Date.now() });
  if(Date.now() - lastTrafficAt > STALE_MS){
    try{ WS?.close(); }catch{}
  }
}

function startHeartbeat(){
  clearInterval(hbTimer);
  touchTraffic();
  hbTimer = setInterval(heartbeatTick, HEARTBEAT_MS);
}
function stopHeartbeat(){
  clearInterval(hbTimer);
  hbTimer=null;
}

function connectWS(){
  const q=qs();

  $("roomPill").textContent = q.room || "‚Äî";
  $("sessionPill").textContent = q.session || "‚Äî";

  // URL can hint event type (optional)
  const urlEvent = normalizeEventType(q.event);
  if(urlEvent) EVENT_TYPE = urlEvent;
  applyEventUI();

  if(!q.room || !q.session){
    setWsStatus("ERROR");
    $("grid").innerHTML = `
      <div class="card matchCard" style="grid-column:1/-1">
        <div class="pair">Missing room/session</div>
        <div class="meta">Host link must include <span class="mono">?room=...&session=...</span></div>
      </div>
    `;
    return;
  }

  stopHeartbeat();
  try{ WS?.close(); }catch{}

  WS = new WebSocket(WS_URL);
  setWsStatus("CONNECTING");

  WS.onopen = () => {
    setWsStatus("CONNECTED");
    touchTraffic();
    startHeartbeat();

    // join as host so the relay can treat this page as privileged if needed
    safeSend({ type:"join", role:"host", roomId:q.room, room:q.room, barId:q.room, session:q.session });

    requestConfig();
    requestSync();
    showToast("Connected", "Requested config + matches");
  };

  WS.onmessage = (ev) => {
    touchTraffic();
    let msg; try{ msg = JSON.parse(ev.data); }catch{ return; }

    if(msg.type==="ping"){
      const q=qs();
      safeSend({ type:"pong", roomId:q.room, room:q.room, barId:q.room, session:q.session, t: Date.now() });
      return;
    }
    if(msg.type==="pong" || msg.type==="heartbeat" || msg.type==="pong_ack") return;

    // CONFIG
    if(msg.type==="config" || msg.type==="event_config"){
      const q=qs();
      const msgRoom = (msg.roomId || msg.room || msg.barId || "").trim();
      if(msg.session && msg.session !== q.session) return;
      if(msgRoom && msgRoom !== q.room) return;

      HOST_CONFIG = msg;

      const fromHostType = inferEventTypeFromConfig(msg);
      if(fromHostType) EVENT_TYPE = fromHostType;

      const fromHostName = inferEventNameFromConfig(msg);
      if(fromHostName) EVENT_NAME = fromHostName;

      applyEventUI();
      populateVenueSelectFromConfig();
      render();
      showToast("Config Loaded", "Venue names updated");
      return;
    }

    // MATCHES SYNC (TV-style)
    if(msg.type==="tv_sync"){
      const q=qs();
      const msgRoom = (msg.roomId || msg.room || msg.barId || "").trim();
      if(msg.session && msg.session !== q.session) return;
      if(msgRoom && msgRoom !== q.room) return;

      lastSyncAt = Date.now();

      const fromSyncType = normalizeEventType(msg.eventType || msg.event || msg.type);
      if(fromSyncType) EVENT_TYPE = fromSyncType;

      matches = (msg.matches || []).map(m => ({
        score: m.score || 0,
        code: m.code || "",
        plan: m.plan || "",
        expiresAt: m.expiresAt || 0,

        aAlias: m.aAlias || m.a || m.aliasA || "",
        bAlias: m.bAlias || m.b || m.aliasB || "",

        aVenueId: m.aVenueId || "",
        bVenueId: m.bVenueId || "",

        aCheckedIn: (typeof m.aCheckedIn === "boolean") ? m.aCheckedIn : (typeof m.checkedInA === "boolean" ? m.checkedInA : undefined),
        bCheckedIn: (typeof m.bCheckedIn === "boolean") ? m.bCheckedIn : (typeof m.checkedInB === "boolean" ? m.checkedInB : undefined),
        aStatus: m.aStatus || m.statusA || "",
        bStatus: m.bStatus || m.statusB || ""
      }));

      setCountsFromMsg(msg);
      setCountsFallback();

      page = 0;
      applyEventUI();
      render();

      showToast("Matches Updated", `${matches.length} match records received`);
      return;
    }
  };

  WS.onerror = () => {
    setWsStatus("ERROR");
    showToast("WebSocket Error", "Connection problem");
    try{ WS?.close(); }catch{}
  };

  WS.onclose = () => {
    setWsStatus("DISCONNECTED");
    stopHeartbeat();
    showToast("Disconnected", "Retrying‚Ä¶");
    setTimeout(connectWS, 2200);
  };
}

/* =========================
   UI events
========================= */
function setFilterMode(mode){
  filterMode = mode;
  page = 0;
  savePrefs();
  render();
}

$("btnFilterHost").addEventListener("click", ()=> setFilterMode("host"));
$("btnFilterAll").addEventListener("click",  ()=> setFilterMode("all"));

$("hostVenueSelect").addEventListener("change", (e)=>{
  hostVenueId = e.target.value || "";
  page = 0;
  savePrefs();
  setHostVenuePill();
  render();
});

$("btnRequestConfig").addEventListener("click", ()=>{
  requestConfig();
  showToast("Requested", "Config request sent");
});

$("btnRequestSync").addEventListener("click", ()=>{
  requestSync();
  showToast("Requested", "Match sync request sent");
});

$("btnToggleAuto").addEventListener("click", ()=>{
  autoOn = !autoOn;
  setAuto();
  showToast("Auto-Refresh", autoOn ? "ON" : "OFF");
});

$("btnClearLocal").addEventListener("click", ()=>{
  try{ localStorage.removeItem(LS_KEY); }catch{}
  showToast("Cleared", "Local cache cleared. Refreshing‚Ä¶");
  location.reload();
});

$("checkedOnly").addEventListener("change", ()=>{
  page = 0;
  savePrefs();
  render();
});

$("rotation").addEventListener("change", ()=>{
  page = 0;
  setRotation();
  render();
});

/* =========================
   Boot
========================= */
(function boot(){
  loadPrefs();

  // apply filter buttons immediately
  $("btnFilterHost").classList.toggle("on", filterMode==="host");
  $("btnFilterAll").classList.toggle("on", filterMode==="all");

  // apply auto + rotation prefs
  $("btnToggleAuto").textContent = `Auto-Refresh: ${autoOn ? "ON" : "OFF"}`;
  setAuto();
  setRotation();

  // initial host venue from URL if we don't have one saved
  const q = qs();
  if(!hostVenueId && q.venue) hostVenueId = q.venue;

  setHostVenuePill();

  // event type from URL (optional)
  EVENT_TYPE = normalizeEventType(q.event) || EVENT_TYPE;
  applyEventUI();

  connectWS();

  // keep sync pill ticking
  setInterval(setSyncPill, 1000);

  // fallback counts refresh
  setInterval(()=>{ if(WS_STATE==="CONNECTED") setCountsFallback(); }, 5000);

  render();
})();
</script>
</body>
</html>























